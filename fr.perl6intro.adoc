= Introduction à Perl 6
:description: Une introduction générale à Perl 6
:Author: Naoum Hankache
:keywords: perl6, perl 6, introduction, perl6intro, perl 6 introduction, Introduction à Perl 6
:Email: naoum@hankache.com
:Revision: 1.0
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:toc-title: Table des matières

L'objectif de ce document est de vous donner un aperçu rapide du langage de programmation Perl 6. +
Pour ceux qui sont nouveaux à Perl 6, il devrait vous permettre de démarrer.

Certaines sections de ce document référencent d'autres parties (plus complètes et précises) de la documentation de Perl 6.
Vous devriez les lire si vous avez besoin de plus d'information sur un sujet précis.

En lisant ce document, vous trouverez des exemples pour la plus part des sujets discutés.
Pour mieux les comprendre, vous pouvez expérimenter en les modifiant.

.Licence
Ce document est sous licence Creative Commons Attribution -  Partage dans les Mêmes Conditions 4.0 International. +
Pour accéder à une copie de cette licence, merci de vous rendre à l'adresse suivante http://creativecommons.org/licenses/by-sa/4.0/.

.Contribution
Si vous souhaitez contribuer à ce document rendez-vous à l'adresse suivante: +
http://github.com/hankache/perl6intro

:sectnums:
== Introduction
=== Perl 6 c'est quoi?
Perl 6 est un langage générique supportant un typage graduel.
Perl 6 supporte plusieurs paradigmes dont, la Programmation Procédurale, Orientée Objet et Fonctionelle.

.Perl 6 motto:
* TMTOWTDI (Prononcé Tim Toady): There is more than one way to do it: +
Il y a plus d'une façon de le faire.
* Easy things should stay easy, hard things should get easier, and impossible things should get hard: +
Les choses faciles doivent rester faciles, les choses dures devraient devenir plus faciles, et les choses impossibles devraient devenir dures.

=== Jargon
Perl 6 est une spécification de langage avec une suite de tests. Les implémentations qui passent la suite de tests sont considérées comme Perl 6. +
Rakudo est un compilateur pour Perl 6. +
Rakudobrew est un gestionnaire d'installation pour Perl 6. +
Panda est un installeur de modules pour Perl 6.

=== Installer Perl 6
.Linux
. Installer Rakudobrew: https://github.com/tadzik/rakudobrew

. Installer Rakudo: Tapez la commande suivante dans le terminal `rakudobrew build moar`

. Installer Panda: Tapez la commande suivante dans le terminal `rakudobrew build-panda`

.OSX
Suivez les mêmes étapes indiquées pour l'installation sur Linux +
ou +
Installer avec homebrew: `brew install rakudo-star`

.Windows
. Téléchargez l'installeur le plus récent (fichier avec une extension .MSI) de http://rakudo.org/downloads/star/ +
Si votre système possède une architecture 32-bit, téléchargez le fichier x86. S'il possède une architecture 64-bit téléchargez le fichier x86_64.
. Apres l'installation, ajouter C:\rakudo\bin a votre PATH

.Docker
. Obtenez l'image officielle `docker pull rakudo-star`
. Ensuite exécutez `docker run -it rakudo-star`

=== Exécuter Perl 6
Pour exécuter un code écrit en Perl 6 vous pouvez utiliser le REPL (Read-Eval-Print Loop). +
Dans votre terminal, tapez `perl6`, tapez votre code et pressez [Enter] +

Alternativement, vous pouvez écrire votre code dans un fichier, l'enregistrer et puis l'exécuter. +
Il est recommandé de créer les fichiers Perl 6 avec l'extension `.pl6`. +
Exécutez le fichier du terminal en utilisant cette syntaxe: `perl6 filename.pl6`

Le REPL est surtout utilisé pour essayer un morceau de code, typiquement une unique ligne de code. +
Pour les programmes contenant plusieurs lignes, il est recommandé de les stocker dans un fichier, puis de les exécuter.

=== Editeurs

Comme la plupart du temps, nous allons écrire et stocker nos programmes en Perl 6 dans des fichiers,
nous devrions avoir un éditeur de texte décent qui reconnaît la syntaxe de Perl 6.

Je recommande personnellement https://atom.io/[Atom]. C'est un éditeur de texte moderne livré avec une coloration syntaxique pour Perl 6.

D'autres personnes de la communauté utilisent aussi http://www.vim.org/[Vim], https://www.gnu.org/software/emacs/[Emacs] ou http://padre.perlide.org/[Padre].

Les versions récentes de Vim sont livrées avec la coloration syntaxique pour Perl 6. Emacs et Padre nécessiteront l'installation de paquets supplémentaires.


=== Bonjour Monde!
Nous allons commencer avec le rituel `hello world`.

[source,perl6]
say 'Bonjour Monde';

=== Aperçu de la syntaxe
Perl 6 est en *forme libre*: Vous êtes libre (la plupart du temps) à utiliser n'importe quelle quantité d'espaces.

Les *Instructions* sont typiquement une ligne logique de code, un point-virgule est nécessaire à leur fin: +
`say "Hello" if True;`

Les *Expressions* sont un type spécial d'instructions qui retournent une valeur: +
`1+2` retourne `3`

Les expressions sont faites de *Termes* et d'*Operateurs*.

Les *Termes* sont des:

* *Variables*: Une valeur qui peut être manipulée ou changée.

* *Littérales*: Une valeur constante comme un nombre ou une chaîne.

Les *Opérateurs* sont classés en types:

|===

| *Type* | *Explication* | *Exemple*

| Préfixe | Avant le terme. | `++1`

| Infixe | Entre deux termes. | `1+2`

| Suffixe | Après le terme. | `1++`

| Circonfixe | Autour du terme. | `(1)`

| Postcirconfixe | Après un terme, autour d'un autre  | `Array[1]`

|===

==== Identificateurs
Les identificateurs sont le nom donné aux termes lors de leur définition.

.Règles:
* Ils doivent commencer par un caractère alphabétique ou un tiret bas (under score).

* Ils peuvent contenir des chiffres (à l'exception du premier caractère).

* Ils peuvent contenir des tirets ou des apostrophes (sauf le premier et le dernier caractère),
mais avec un caractère alphabétique sur le côté droit de chaque tiret / apostrophe.

|===

| *Valide* | *Non valide*

| `var1` | `1var`

| `var-one` | `var-1`

| `var'one` | `var'1`

| `var1_` | `var1'`

| `_var` | `-var`

|===

.Conventions de nommage:
* Camel: `variableNo1`

* Kebab: `variable-no1`

* Snake: `variable_no1`

Vous êtes libre de nommer vos identificateurs comme vous le souhaitez,
mais choisissez une convention de nommage et tenez-vous y.

L'utilisation de noms signifiants facilitera votre vie et celle des autres. +
`var1 = var2 * var3` est syntaxiquement correct mais son but n'est pas évident. +
`salaire-mensuel = salaire-journalier * jours-travaillés` serait une meilleure façon de nommer vos variables.

==== Commentaires
Un commentaire est du texte ignoré par le compilateur.

Il y a 3 types de commentaires:

* Ligne unique:
+
[source,perl6]
#Ceci est une seule ligne de commentaire

* Intégré:
+
[source,perl6]
say #`(Ceci est un commentaire intégré) "Bonjour Monde."

* Multi ligne:
+
[source,perl6]
-----------------------------
=begin comment
Ceci est un commentaire sur plusieurs lignes.
Commentaire 1
Commentaire 2
=end comment
-----------------------------

==== Guillemets
Les chaînes doivent être délimitées par des guillemets droits doubles ou simples.

Utilisez toujours des guillemets droits doubles:

* si votre chaîne contient une apostrophe.

* si votre chaîne contient une variable qui doit être interpolée.

[source,perl6]
-----------------------------------
say 'Bonjour Monde';               #Bonjour Monde
say "Bonjour Monde";               #Bonjour Monde
say "Quelqu'un m'a dit";           #Quelqu'un m'a dit
my $nom = 'Jean Dupont';
say 'Salut $name';               #Salut $nom
say "Salut $name";               #Salut Jean Dupont
-----------------------------------

== Operateurs
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Operateur | Type | Description | Exemple | Résultat

| + | Infixe | Addition | 1 + 2 | 3

| - | Infixe | Soustraction | 3 - 1 | 2

| * | Infixe | Multiplication | 3 * 2 | 6

| ** | Infixe | Puissance | 3 ** 2 | 9

| / | Infixe | Division | 3 / 2 | 1.5

| div | Infixe | Division (arrondi) | 3 div 2 | 1

| % | Infixe | Reste | 7 % 4 | 3

.2+| %% .2+| Infixe .2+| Divisibilité | 6 %% 4 | False

<| 6 %% 3 <| True

| gcd | Infixe | Plus grand dénominateur commun | 6 gcd 9 | 3

| lcm | Infixe | Plus petit commun multiple | 6 lcm 9 | 18

| == | Infixe | Egalité | 9 == 7  | False

| != | Infixe | Inégalité | 9 != 7  | True

| < | Infixe | Plus petit | 9 < 7  | False

| > | Infixe | Plus grand | 9 > 7  | True

| \<= | Infixe | Plus petit ou égal | 7 \<= 7  | True

| >= | Infixe | Plus grand ou égal | 9 >= 7  | True

| eq | Infixe | Egalité (chaînes) | "John" eq "John"  | True

| ne | Infixe | Inégalité (chaînes) | "John" ne "Jane"  | True

| = | Infixe | Affectation | my $var = 7  | Attribue la valeur `7` a la variable `$var`

.2+| ~ .2+| Infixe .2+| Concaténation | 9 ~ 7 | 97

<m| "Hi " ~ "there"  <| Hi there

.2+| x .2+| Infixe .2+| Réplication | 13 x 3  | 131313

<| "Hello " x 3  <| Hello Hello Hello

| ~~ | Infixe | Smart match |   |

.2+| ++ | Préfixe | Incrémentation | my $var = 2; ++$var;  | Incrémente la variable de 1 et retourne le résultat `3`

<m| Suffixe <d| Incrémentation <m| my $var = 2; $var++;  <| Retourne la variable `2` et puis l'incrémente

.2+|\--| Préfixe | Décrémentation | my $var = 2; --$var;  | Décrémente la variable de 1 et retourne le résultat `1`

<m| Suffixe <d| Décrémentation <m| my $var = 2; $var--;  <| Retourne la variable `2` et puis la décrémente

.3+| + .3+| Préfixe .3+| Force l'opérande a une valeur numérique | +"3"  | 3

<| +True <| 1

<| +False <| 0

.3+| - .3+| Préfixe .3+| Force l'opérande a une valeur numérique et retourne la négation | -"3"  | -3

<| -True <| -1

<| -False <| 0

.6+| ? .6+| Préfixe .6+| Force l'opérande a une valeur booléenne | ?0 | False

<| ?9.8 <| True

<| ?"Hello" <| True

<| ?"" <| False

<| my $var; ?$var; <| False

<| my $var = 7; ?$var; <| True

| ! | Préfixe | Force l'opérande a une valeur booléenne et retourne la négation | !4 | False

| .. | Infixe | Construction de gammes |  0..5  | Crée une gamme de 0 a 5

| ..^ | Infixe | Construction de gammes |  0..^5  | Crée une gamme de 0 a 4

| ^.. | Infixe | Construction de gammes |  0^..5  | Crée une gamme de 1 a 5

| \^..^ | Infixe | Construction de gammes |  0\^..^5  | Crée une gamme de 1 a 4

| ^ | Préfixe | Construction de gammes |  ^5  | Comme 0..^5 Crée une gamme de 0 a 4

| ... | Infixe | Construction de listes paresseuses |  0...9999  |  Retourne les éléments seulement si nécessaire

.2+| {vbar} .2+| Préfixe .2+| Aplanissement | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

NOTE: Pour la liste complète des opérateurs, y compris leur priorité: http://doc.perl6.org/language/operators

== Variables
Les variables sont classées en 3 catégories: Scalaires, Tableaux et Hachages.

Un *sigil* (Signe en Latin) est un caractère utilisé comme préfixe pour classer les variables.

* `$` est utilisé pour les scalaires
* `@` est utilisé pour les tableaux
* `%` est utilisé pour les tables de hachage.

=== Scalaires
Un scalaire tient une valeur ou une référence.

[source,perl6]
----
#Chaine
my $nom = 'Jean Dupont';
say $name;

#Entier
my $age = 99;
say $age;
----

=== Tableaux
Les tableaux sont des listes contenant plusieurs valeurs.

[source,perl6]
----
my @animaux = ['chameau','llama','hibou'];
say @animaux;
----

De nombreuses opérations peuvent être effectuées sur les tableaux comme démontré dans l'exemple suivant:

TIP: Le tilde `~` est utilisé pour la concaténation.

[source,perl6]
.`Script`
----
my @animaux = ['chameau','vigogne','lama'];
say "Le zoo contient " ~ @animaux.elems ~ " animaux";
say "Les animaux sont: " ~ @animaux;
say "Je vais adopter un hibou pour le zoo";
@animaux.push("hibou");
say "Maintenant, mon zoo contient: " ~ @animaux;
say "Le premier animal que nous avons adopté est le " ~ @animaux[0];
@animaux.pop;
say "Malheureusement, le hibou est parti, il ne nous reste que: " ~ @animaux;
say "Nous allons fermer le zoo et laisser un animal seulement";
say "Nous allons laisser partir: " ~ @animaux.splice(1,2) ~ " et laisser le " ~ @animaux;
----

.`Sortie`
----
Le zoo contient 3 animaux
Les animaux sont: chameau vigogne lama
Je vais adopter un hibou pour le zoo
Maintenant, mon zoo contient: chameau vigogne lama hibou
Le premier animal que nous avons adopté est le chameau
Malheureusement, le hibou est parti, il ne nous reste que: chameau vigogne lama
Nous allons fermer le zoo et laisser un animal seulement
Nous allons laisser partir: vigogne lama et laisser le chameau
----

.Explication
`.elems` retourne le nombre d'éléments contenus dans le tableau. +
`.push()` ajoute un élément au tableau. +
Nous pouvons accéder à un élément spécifique dans le tableau en spécifiant sa position `@animaux[0]`. +
`.pop` supprime le dernier élément du tableau. +
`.splice(a,b)` supprime les `b` éléments a partir de la position `a`.

NOTE: Pour la référence complète des tableaux: http://doc.perl6.org/type/Array

=== Hachage
Un hachage (table de hachage / hash) est un ensemble de paires clef / valeur.

[source,perl6]
----------------------------------------------------
my %capitales = ('Londres','Angleterre','Paris','France');
say %capitales;

#une autre façon succincte de remplir le hachage:
my %capitales = (Londres => 'Angleterre', Paris => 'France');
say %capitales;
----------------------------------------------------

=== Types
Dans les exemples précédents, on n'a pas précisé quel type de valeurs les variables peuvent tenir.

TIP: `.WHAT` retournera le type de la valeur contenue dans la variable.

[source,perl6]
---------------------
my $var = 'Texte';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
---------------------

Comme vous pouvez le voir dans l'exemple ci-dessus, le type de valeur contenu dans `$var` était (Str) et puis (Int).

Ce style de programmation est appelé le typage dynamique.
Dynamique dans le sens que les variables peuvent contenir des valeurs de tout type.

Maintenant, essayez d'exécuter l'exemple ci-dessous: +
Remarquez `Int` avant le nom de la variable.

[source,perl6]
-----------------------------------------
my Int $var = 'Texte';
say $var;
say $var.WHAT;
-----------------------------------------

Il va échouer et retourner ce message d'erreur: `Type check failed in assignment to $var; expected Int but got Str`

Ce qui est arrivé est que nous avons précisé au préalable que la variable doit être de type (Int).
Quand nous avons essayé de lui affecter un (Str), le programme a échoué.

Ce style de programmation est appelé le typage statique. Statique dans le sens que les types de variables sont définies avant l'affectation et ne peuvent pas changer.

Perl 6 possède un *typage graduel*; les deux typages *statique* et *dynamique* peuvent être utilisés.

Voici une liste des types les plus couramment utilisés. +
Les deux premiers ne seront probablement jamais utilisés, mais ils sont répertoriés à titre informatif.

[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Type* | *Description* | *Exemple* | *Résultat*

| Mu | La racine de la hiérarchie de types | |

| Any | Classe de base par défaut pour les nouvelles classes et pour la plupart des classes intégrées | |

| Cool | Valeur qui peut être considérée comme une chaîne ou un nombre interchangeable | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | Chaîne de caractères | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Entier (précision arbitraire) | 7 + 7 | 14

| Rat | Nombre rationnel (précision limitée) | 0.1 + 0.2 | 0.3

| Bool | Booléen | !True | False

|===

=== Introspection

L'introspection est le processus d'obtention d'informations sur les propriétés d'un objet comme son type. +
Dans l'exemple précédent, nous avons utilisé `.WHAT` pour recevoir le type de la variable.

[source,perl6]
----
my Int $var;
say $var.WHAT;
my $var2;
say $var2.WHAT;
$var2 = 1;
say $var2.WHAT;
$var2 = "Bonjour";
say $var2.WHAT;
$var2 = True;
say $var2.WHAT;
$var2 = Nil;
say $var2.WHAT;
----

----
(Int)
(Any)
(Int)
(Str)
(Bool)
(Any)
----

Le type d'une variable contenant une valeur est corrélée à sa valeur. +
Le type d'une variable vide fortement déclarée est le type avec lequel elle a été déclarée. +
Le type d'une variable vide qui n'a pas été déclarée fortement est `(Any)` +
Pour vider la valeur d'une variable, vous pouvez lui affecter `Nil`.

=== Portée
Avant d'utiliser une variable pour la première fois, elle doit être déclarée.

Plusieurs déclarateurs peuvent être utilisés dans Perl 6, `my` est ce que nous avons utilisé jusqu'ici.

[source,perl6]
my $var=1;

Le déclarateur `my` donne à la variable une portée *lexicale*.
En d'autres termes, la variable ne sera accessible que dans le bloc ou elle a été déclarée.

Un bloc en Perl 6 est délimité par `{ }`.
Si aucun bloc n'est trouvé, la variable sera disponible dans l'ensemble du script.

[source,perl6]
--------------------------------
{
  my Str $var = 'Texte';
  say $var; #accessible
}
say $var; #inaccessible, renvoie une erreur
--------------------------------

Comme une variable est uniquement accessible dans le bloc où elle est définie, le même nom de variable peut être redéfini dans un autre bloc.

[source,perl6]
----
{
  my Str $var = 'Texte';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Affectation vs. Lien
Nous avons vu dans les exemples précédents, comment *affecter* des valeurs aux variables. +
L'*affectation* est faite en utilisant l'opérateur `=`
[source,perl6]
----
my Int $var = 123;
say $var;
----

Nous pouvons modifier la valeur attribuée à une variable:

[source,perl6]
.Affecter
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Sortie`
----
123
999
----

D'autre part, nous ne pouvons pas changer la valeur *liée* à une variable. +
Le *lien* est fait en utilisant l'opérateur `:=`

[source,perl6]
.Lier
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Sortie`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.Une variables peut être également liée a une autre:
----
my $a;
my $b := $a;
$a = 7;
say $b;
----

NOTE: Pour plus d'informations sur les variables, rendez-vous à http://doc.perl6.org/language/variables

== Fonctions normales et fonctions mutantes

Il est important de différencier entre les fonctions normales et les fonctions mutantes. +
Les fonctions normales ne changent pas l'état initial de l'objet. +
Les fonctions mutantes modifient l'état de l'objet.

[source,perl6,linenums]
.`Script`
----
my @numeros = [7,2,4,9,11,3];

@numeros.push(99);
say @numeros;      #1

say @numeros.sort; #2
say @numeros;      #3

@numeros.=sort;
say @numeros;      #4
----

.`Sortie`
----
[7 2 4 9 11 3 99] #1
(2 3 4 7 9 11 99) #2
[7 2 4 9 11 3 99] #3
[2 3 4 7 9 11 99] #4
----

.Explication
`.push` est une fonction mutante, elle change l'état du tableau (#1)

`.sort` est une fonction normale, elle retourne un tableau trié, mais ne modifie pas l'état initial du tableau:

* (#2) démontre le retour d'un tableau trié

* (#3) démontre que le tableau initial reste non modifie.

Afin de forcer une fonction normale à agir comme une fonction mutante, nous pouvons utiliser `.=` a la place de `.` (#4) (Ligne 9 du script)

== Structures conditionnelles et boucles
Perl 6 possède une multitude de structures conditionnelles et structures de boucles.

=== if
Le code ne fonctionne que si la condition a été remplie.

[source,perl6]
----
my $age = 19;

if $age > 18 {
  say 'Bienvenue'
}
----

En Perl 6, nous pouvons inverser le code et la condition. +
Même si le code et la condition ont été inversées, la condition est toujours évaluée en premier.

[source,perl6]
----
my $age = 19;

say 'Bienvenue' if $age > 18;
----

Si la condition n'est pas remplie, nous pouvons toujours préciser des blocs d'exécution alternatifs en utilisant:

* `else`
* `elsif`

[source,perl6]
----
#exécuter le même code pour différentes valeurs de la variable
my $nombre-de-places = 9;

if $nombre-de-places <= 5 {
  say 'Je suis une berline'
} elsif $nombre-de-places <= 7 {
  say 'Je suis un monospace'
} else {
  say 'Je suis un van'
}
----

=== unless
La version négative d'un `if` peut être écrite en utilisant `unless`.

Le code suivant:

[source,perl6]
----
my $chaussures-propres = False;

if not $chaussures-propres {
  say 'Nettoyez vos chaussures'
}
----
peut aussi être écrit ainsi:

[source,perl6]
----
my $chaussures-propres = False;

unless $chaussures-propres {
  say 'Nettoyez vos chaussures'
}
----

La négation en Perl 6 est faite en utilisant `!` ou `not`.

`unless (condition)` est utilisé à la place de `if not (condition)`.

`unless` ne peux pas avoir une clause `else`.

=== with

`with` fonctionne comme `if`, mais vérifie si la variable est définie.

[source,perl6]
----
my Int $var=1;

with $var {
  say 'Bonjour'
}
----

Si vous exécutez le code sans attribuer une valeur à la variable, rien ne devrait arriver.
[source,perl6]
----
my Int $var;

with $var {
  say 'Bonjour'
}
----

`without` est la version négative de `with`. Vous devriez être capable de le relier le concept à `unless`.

Si la première condition `with` n'est pas remplie, un autre chemin peut être spécifié en utilisant `orwith`. +
`with` et `orwith` peuvent être comparés à `if` et `elsif`.

=== for

La boucle `for` itère sur plusieures valeurs.

[source,perl6]
----
my @tableau = [1,2,3];

for @tableau -> $element {
  say $element*100
}
----

Notez que nous avons créé une variable d'itération `$element` afin d'effectuer l'opération `*100` sur chaque élément du tableau.

=== given

`given` est l'équivalent Perl 6 de l'instruction switch dans d'autres langues.

[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Plus petit que 50'}
    when Int { say "est un Int" }
    when 42  { say 42 }
    default  { say "huh?" }
}
----

Après un appariement réussi, le processus d'appariement arrêtera.

Alternativement `proceed` instruira Perl 6 à poursuivre l'appariement, même après un appariement réussi.
[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Plus petit que 50';proceed}
    when Int { say "est un Int";proceed}
    when 42  { say 42 }
    default  { say "huh?" }
}
----

=== loop

`loop` est une autre façon d'écrire une boucle `for`.

En fait `loop` s'écrit comme le sont les boucles `for` dans les langages de programmation appartenant a la famille-C.

Perl 6 appartient à la famille-C

[source,perl6]
----
loop (my $i=0; $i < 5; $i++) {
  say "Le nombre actuel est $i"
}
----

NOTE: Pour plus d'informations sur les boucles et les conditions, voir http://doc.perl6.org/language/control

== E/S
En Perl 6, deux des interfaces _entrée/sortie_ les plus communes sont le _Terminal_ et les _Fichiers_.

=== E/S Basic en utilisant le Terminal

==== say
`say` écrit sur l'interface de sortie standard. Il ajoute une nouvelle ligne à la fin. En d'autres termes, le code suivant:

[source,perl6]
----
say 'Bonjour Madame.';
say 'Bonjour Monsieur.';
----
sera écrit sur 2 lignes distinctes.

==== print
`print` d'autre part fonctionne comme `say` mais sans ajouter une nouvelle ligne.

Essayez de remplacer `say` avec `print` et de comparer les deux résultats.

==== get
`get` est utilisé pour capturer l'entrée du Terminal.

[source,perl6]
----
my $nom;

say "Salut quel est ton nom?";
$nom=get;

say "Cher $nom bienvenue à Perl 6";
----

Lorsque le code ci-dessus est lancé, le terminal vous attendra pour saisir votre nom.
Par la suite, il vous accueillera.

==== prompt
`prompt` est une combinaison de `print` et `get`.

L'exemple ci-dessus peut être écrit comme ceci:

[source,perl6]
----
my $nom = prompt("Salut quel est ton nom? ");

say "Cher $nom bienvenue à Perl 6";
----

=== Exécution de commandes Shell
Deux sous-programmes peuvent être utilisés pour exécuter des commandes shell:

* `run` Exécute une commande externe sans impliquer le Shell

* `shell` Exécute une commande via le shell. Tous les méta-caractères sont interprétés par le shell, y compris les tuyaux, les redirections, les variables d'environnement etc.

[source,perl6]
----
my $nom = 'Neo';
my $commande = run 'echo', "salut $name";
my $commande2 = shell "ls";
----
`echo` et `ls` sont des mots clés communs de shell. +
`echo` imprime le texte sur le Terminal (l'équivalent de `print` en Perl 6) +
`ls` liste tous les fichiers et dossiers dans le répertoire courant


=== E/S Fichier
==== slurp
`slurp` est utilisé pour lire les données d'un fichier.

Créez un fichier texte avec le contenu suivant:

.datafile.txt
----
John 9
Johnnie 7
Jane 8
Joanna 7
----
[source,perl6]
----
my $data = slurp "datafile.txt";
say $data;
----

==== spurt
`spurt` est utilisé pour écrire des données sur un fichier.

[source,perl6]
----
my $newdata = "New scores:
Paul 10
Paulie 9
Paulo 11";

spurt "newdatafile.txt", $newdata;
----

Après avoir exécuté le code ci-dessus, un nouveau fichier nommé _newdatafile.txt_ sera créé. Il contiendra les nouveaux scores.

=== Travailler avec les fichiers et répertoires
Perl 6 peut lister le contenu d'un répertoire sans exécuter des commandes shell (en utilisant `ls`) comme nous l'avons vu dans un exemple précédent.

[source,perl6]
----
say dir;              #Liste les fichiers et dossiers dans le répertoire courant
say dir "/Documents"; #Liste les fichiers et dossiers dans le répertoire spécifié
----

De plus, vous pouvez créer de nouveaux dossiers et les supprimer.

[source,perl6]
----
mkdir "newfolder";
rmdir "newfolder";
----

`mkdir` crée un nouveau répertoire. +
`rmdir` supprimer un répertoire vide. Renvoie une erreur s'il n'est pas vide.

Vous pouvez également vérifier si le chemin d'accès spécifié existe, s'il est un fichier ou un répertoire:

Dans le répertoire où vous allez exécutez le script ci-dessous, créez un dossier vide `folder123` et un fichier .pl6 vide `script123.pl6`

[source,perl6]
----
say "script123.pl6".IO.e;
say "folder123".IO.e;

say "script123.pl6".IO.d;
say "folder123".IO.d;

say "script123.pl6".IO.f;
say "folder123".IO.f;
----

`IO.e` vérifie si le répertoire/fichier existe. +
`IO.f` vérifie si c'est un fichier. +
`IO.d` vérifie si c'est un dossier.

NOTE: Pour plus d'informations sur les E/S, voir http://doc.perl6.org/type/IO

== Sous-programmes
=== Définition
Les *sous-programmes* ou *subroutines* ou *subs* sont un moyen de conditionnement d'un ensemble de fonctionnalités.

Un sous-programme est défini avec le mot-clé `sub`. Après leur définition, ils peuvent être appelés par leur nom. +
Examinez l'exemple ci-dessous:

[source,perl6]
----
sub salut-alien {
  say "Bonjour Terriens";
}

salut-alien;
----

L'exemple précédent présente un sous-programme qui ne nécessite aucun argument.

=== Signature
Beaucoup de sous-programmes requièrent une certaine entrée pour fonctionner. Cette entrée est fournie par des *arguments*. +
La *signature* est le nombre et le type d'arguments que le sous-programme accepte.

Le sous-programme ci-dessous accepte une chaîne pour argument:

[source,perl6]
----
sub dis-bonjour (Str $nom) {
    say "Bonjour " ~ $nom ~ "!!!!"
}
dis-bonjour "Paul";
dis-bonjour "Paula";
----

=== Multi sous-programmes
Il est possible de définir plusieurs sous-programmes ayant le même nom, mais différentes signatures.
Lorsque le sous-programme est appelé, l'environnement d'exécution décidera quelle version utiliser en fonction du nombre et du type des arguments fournis.
Ce type de sous-programmes est défini de la même manière que les sous-programmes normaux sauf que nous utilisons le mot-clé 'multi' a la place de 'sub'.

[source,perl6]
----
multi salut($nom) {
    say "Bonne Journée $nom";
}
multi salut($nom, $titre) {
    say "Bonne Journée $titre $nom";
}

salut "Gaspard";
salut "Josiane","Mme.";
----

=== Arguments optionnels et par défaut
Si un sous-programme est défini comme acceptant un argument, et nous l'appelons sans fournir l'argument requis, le sous-programme va échouer.

Alternativement Perl 6 nous offre la possibilité de définir des sous-programmes avec des:

* Arguments Optionnels
* Arguments par Défaut

Les arguments optionnels sont définis en ajoutant `?` après le nom de l'argument.

[source,perl6]
----
sub dis-bonjour($nom?) {
  with $nom { say "Bonjour " ~ $nom }
  else { say "Bonjour être humain" }
}
dis-bonjour;
dis-bonjour("Laura");
----

Si l'utilisateur ne fournit pas un argument, le sous-programme peut fournir une valeur par défaut. +
Cela se fait par l'attribution d'une valeur à l'argument durant la définition du sous-programme.

[source,perl6]
----
sub dis-bonjour($nom="Raoul") {
  say "Bonjour " ~ $nom;
}
dis-bonjour;
dis-bonjour("Laura");
----

NOTE: Pour plus d'informations sur les sous-programmes et fonctions, voir http://doc.perl6.org/language/functions

== Programmation Fonctionnelle
Ce chapitre traitera de des fonctionalités facilitant la programmation fonctionnelle

=== Les fonctions sont des entités de première classe
Les fonctions/sous-programmes sont des entités de première classe

* Elles peuvent être passées comme un argument

* Elles peuvent être retournées par une fonction

* On peut les assigner à une variable

Un bon exemple pour vérifier ce concept est la fonction `map`. +
`map` est une *fonction d'ordre supérieur*, elle accepte une autre fonction comme argument.

[source,perl6]
.Script
----
my @tableau = <1 2 3 4 5>;
sub carré($x) {
  $x ** 2
}
say map(&carré,@tableau);
----

.Sortie
----
(1 4 9 16 25)
----

.Explication
Nous avons définit un sous-programme appelé `carré`, qui met à la puissance 2 tous les arguments qui lui sont passés. +
Ensuite, nous avons utilisé `map`, un fonction d'ordre supérieur en lui passant 2 arguments, un sous-programme et un tableau.+
Le résultat est une liste de tous les éléments du tableau mis à la puissance 2.

Notez que quand un sous-programme est passé comme argument, nous le préfixons avec `&`.

=== Fermeture
Tous les objets code en Perl 6 sont des fermetures, ce qui implique qu'ils peuvent référencer des variables lexicales d'une portée externe.

=== Fonctions anonymes
Une *fonction anonyme* est également appelée *lambda*. +
Une fonction anonyme n'est pas liée à un identifiant (elle n'a pas de nom).

Ré-écrivons l'exemple de `map` avec une fonction anonyme
[source,perl6]
----
my @tableau = <1 2 3 4 5>;
say map(-> $x {$x ** 2},@tableau);
----
Notez qu'au lieu de déclarer un sous-programme et de le passer en argument à `map`, nous le déclarons directement à l'intérieur de `map`. +
Le sous-programme anonyme `\-> $x {$x ** 2}` n'a pas de handle et ne peut donc pas être appelé.

En dialecte Perl 6 nous l'appelons un *bloc pointu* (pointy block)

[source,perl6]
.Un bloc pointu peut aussi être utilisé pour assigner des fonctions à des variables:
----
my $carré = -> $x {
  $x ** 2
}
say $carré(9);
----

=== Enchaînement
En Perl 6 le méthodes peuvent être enchaînées, vous n'avez plus à passer le résultat d'une méthode comme argument à une autre.

Considérons qu'on vous donne un tableau de valeurs.
On vous demande de retourner les valeurs uniques de ce tableau en ordre décroissant.

Vous pouvez résoudre ce problème en écrivant quelquechose comme ceci:
[source,perl6]
----
my @tableau = <7 8 9 0 1 2 4 3 5 6 7 8 9 >;
my @tableau-final = reverse(sort(unique(@tableau)));
say @tableau-final;
----
Nous appelons d'abord la fonction `unique` sur `@tableau` puis nous passons le résultat comme argument à `sort` et ensuite passons le résultat à `reverse`.

En miroir de l'exemple ci-dessus, l'enchaînement de methodes est aussi possible en Perl 6. +
l'exemple ci dessus peut aussi être écrit comme suit, en prennant avantacge de *l'enchaînement des méthodes*:

[source,perl6]
----
my @tableau = <7 8 9 0 1 2 4 3 5 6 7 8 9 >;
my @tableau-final = @tableau.unique.sort.reverse;
say @tableau-final;
----

Vous pouvez constater qu'enchaîner les méthodes est _plus agréable à l'oeil et au cerveau_.

=== Feed Operator
Le *feed operator*, appelé _Pipe_ dans d'autres langages fonctionnels, donne une meilleure vue sur du l'enchaînement de méthodes.
[source,perl6]
.Feed vers l'avant
----
my @tableau = <7 8 9 0 1 2 4 3 5 6>;
@tableau ==> unique()
         ==> sort()
         ==> reverse()
         ==> my @tableau-final;
say @tableau-final;
----

.Explication
----
Commence avec `@tableau` puis renvoie la liste des éléments uniques
                         puis effectue un tri
                         puis l'inverse
                         puis stocke le résultat dans @tableau-final
----
Comme vous le voyez, le flux des appels de méthodes se fait de haut en bas.


[source,perl6]
.Feed vers l'arrière
----
my @tableau = <7 8 9 0 1 2 4 3 5 6>;
my @tableau-final-v2 <== reverse()
                     <== sort()
                     <== unique()
                     <== @array;
say @tableau-final-v2;
----

.Explication
Le feed vers l'arrière est comme celui vers l'avant mais se fait à rebours. +
Le flux des appels de méthodes se fait de bas en haut.

=== Hyperopérateur
L' *hyperpérateur* `>>.` appellera une methode sur tous les éléments d'une liste et retournera une liste des résultats.
[source,perl6]
----
my @tableau = <0 1 2 3 4 5 6 7 8 9 10>;
sub est-pair($var) { $var %% 2 };

say @tableau>>.is-prime;
say @tableau>>.&est-pair;
----

En utilisant l'hyperopérateur nous pouvons appeler des méthodes déjà définies dans Perl 6, ex: `is-prime` qui nous indique si un nombre est premier ou pas. +
Nous pouvons également définir de nouveaux sous-programmes et les appeler en utilisant l'hyperopérateur. En ce cas, il faut préfixer la méthode avec `&`. ex: `&est-pair` 

Cette façon de faire est très pratique, car elle nous évite d'écrire une boucle `for` d'itéreration sur chaque valeur.

=== Jonctions
Une *jonction* est une superposition logique des valeurs.

L'exemple ci-dessous `1|2|3` est une jonction.
[source,perl6]
----
my $var = 2;
if $var == 1|2|3 {
  say "La variable est soit 1 ou 2 ou 3";
}
----
L'utilisation de jonctions déclenche généralement l'*autothreading*;
l'opération est effectuée pour chaque élément de la jonction, les résultats sont combinés en une seule jonction et revoyés.


=== Listes Paresseuses
Une *liste paresseuse* est une liste dont l'évaluation peut être retardée. +
L'évaluation paresseuse diffère l'évaluation d'une expression jusqu'au momment où celle-ci est necessaire, et evite ainsi la répétition des évaluations en stockant les résultats dans une table de correspondance.

Les avantages, parmi d'autres, sont les suivants:

* Un gain de performance évitant les calculs inutiles

* La possibilité de construire des structures de données potentiellement infinies

* La possibilité de définir une structure de contrôle

Pour construire une liste paresseuse on utilise l'opérateur infixe `...` +
Une liste paresseuse possède *un ou des éléments initiaux*, *un générateur*, et un *point final*.

[source,perl6]
.Liste Paresseuse Simple
----
my $lazylist = (1 ... 10);
say $lazylist;
----
L'élément initial est 1, et le point final est 10. Aucun générateur n'a été définit donc le générateur par défaut se fait par sucession (+1) +
En d'autres termes cette liste paresseuse retournera (si appelée) les éléments suivants: (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

[source,perl6]
.Liste paresseuse Infinie
----
my $lazylist = (1 ... Inf);
say $lazylist;
----
Cette liste retournera (si appelée) les entiers entre 1 et l'infini, en d'autres termes tous les entiers.

[source,perl6]
.Liste paresseuse utilisant un générateur déduit
----
my $lazylist = (0,2 ... 10);
say $lazylist;
----
Les éléments initiaux sont 0 et 2, et le point final est 10.
Aucun générateur n'est définit, mais en utilisant les éléments initiaux, Perl 6 déduira que le générateur est (+2) +
Cette liste paresseuse retournera (si appelée) les éléments suivants: (0, 2, 4, 6, 8, 10)

[source,perl6]
.Liste paresseuse utilisant un générateur définit
----
my $lazylist = (0, { $_ + 3 } ... 12);
say $lazylist;
----
Dans cet exemple, nous définisson explicitement un générateur mis entre `{ }` +
Cette liste paresseuse retournera (si appelée) les éléments suivants: (0, 3, 6, 9, 12)

[WARNING]
--
Si vous utilisez un générateur explicite, le point final doit être une valeur que le générateur puisse retourner. +
Si nous reproduisons l'exemple ci-dessus avec un point final égal à 10 au lieu de 12, il n'y aura pas de fin.
Le générateur _saute par dessus_ le point final.

Vous pouvez sinon remplacer `0 ... 10` par `0 ...^ * > 10` +
Ce qui se lit comme: de 0 jusqu'a la première valeur suppérieure à 10 exclu
[source,perl6]
.Ceci ne stopera pas le générateur
----
my $lazylist = (0, { $_ + 3 } ... 10);
say $lazylist;
----

[source,perl6]
.Ceci stopera le générateur
----
my $lazylist = (0, { $_ + 3 } ...^ * > 10);
say $lazylist;
----
--


== Classes & Objets
Dans le chapitre précédent nous avons vu comment Perl 6 facilite la Programmation Fonctionnelle. +
Dans ce chapitre nous allons aborder la Programmation Orientée Objet en Perl 6.

=== Introduction

la Programmation _Orientée Objet_ est l'un des paradigmes les plus utilisés de nos jours. +
Un *objet* est une collection de variables et sous-programmes empaquetés ensemble. +
Les variables sont appelées des *attributs* et les sous-programmes des *méthodes*. +
Les attributs définissent l'*état* et les méthodes le *comportement* d'un objet.

Une *classe* définit la structure d'une collection d'*objets*. +

Pour comprendre cette relation, examinez l'exemple ci-dessous:

|===

| Il y a 4 personnes présentes dans une pièce | *objets* => 4 personnes

| Ces 4 personnes sont des êtres humains | *classe* => Humain

| Ils ont des noms, ages, sexes et nationalités différents | *attributs* => nom, age, sexe, nationalité

|===

Dans le jargon _orienté objet_ nous disons que les objets sont des *instances* d'une classe.

Voyez le script ci-dessous:
[source,perl6]
----
class Humain {
  has $nom;
  has $age;
  has $sexe;
  has $nationalité;
}

my $françois
$françois = Humain.new(nom => 'François', age => 23, sexe => 'M', nationalité => 'Sarthoise');
say $françois;
----
Le mot-clef `class` est utilisé pour définir une classe. +
Le mot-clef `has` est utilisé pour définir un attribut d'une classe. +
La méthode `.new()` est appelée un *constructeur*. Elle crée l'objet comme une instance de la classe sur laquelle il a été appelé.

Dans le script ci-dessus, la nouvelle variable `$françois` contient un référence vers une nouvelle instance de "Humain" définie par `Humain.new()`. +
Les arguments passés à la méthode `.new()` sont utilisés pour initialiser les attributs de l'objet.

Une classe peut se voir donner une _portée lexicale_ en utilisant `my`:
[source,perl6]
----
my class Humain {

}
----

=== Encapsulation
L'encapsulation est un concept orienté objet qui rassemble une collection de données et de méthodes. +
Les données (attributs) dans un objet se doivent d'être *privées*, en d'autres termes, accessibles seulement à l'intérieur de l'objet. +
pour avoir accès aux attributs depuis l'extérieur de l'objet on utilise des méthodes appelées *accesseurs*.

Les deux scripts ci-dessous ont le même résultat.

.Accès direct à la variable:
[source,perl6]
----
my $var = 7;
say $var;
----

.Encapsulation:
[source,perl6]
----
my $var = 7;
sub disvar {
  $var;
}
say disvar;
----
La méthode `disvar` est un accesseur. Il nous permet d'avoir accès à la valeur de la variable sans avoir d'accès direct à celle-ci.

L'encapsulation est facilitée en Perl 6 par l'emploi de *twigils*. +
Les twigils sont des _sigils_ secondaires. Il s'intercalent entre le sigil et le nom de l'attribut. +
On utilise 2 twigils dans les classes:

* `!` est utilisé pour déclarer explicitement qu'un attribut est privé.
* `.` est utilisé pour générer automatiquement un accesseur pour un attribut.

Par défaut, tout les attributs sont privés, mais c'est une saine habitude que d'utiliser le twigil `!`.

En accord avec ce qui vient d'être dit, nous devrions ré-écrire la classe comme suit:
[source,perl6]
----
class Humain {
  has $!nom;
  has $!age;
  has $!sexe;
  has $!nationalité;
}

my $françois = Humain.new(nom => 'François', age => 23, sexe => 'M', nationalité => 'Sarthoise');
say $françois;
----
Si vous ajoutez à ce script la ligne suivante: `say $françois.age;` +
L'erreur suivante sera retournée: `Method 'age' not found for invocant of class 'Humain'` +
La raison en est que `$!age` est privé et ne peut être utilisé que dans l'objet.
Y avoie accès en dehors de l'objet retournera une erreur.

Maintenant remplacez `has $!age` par `has $.age` et voyez quel est le résultat de `say $françois.age;`

=== Arguments Nommés vs. Positionnels
En Perl 6, toutes les classes héritent d'un constructeur par défaut `.new()`. +
Il peut être utilisé pour créer des objets en leur fournissant des arguments. +
Le constructeur par défaut ne peut se voir fournir que des *arguments nommés*. +
Si vous regardez l'exemple ci-dessus, vous voyez que les arguments passés à `.new()` sont définis par leur noms: 

* nom => 'François'

* age => 23

Et si je ne veux pas passer le nom de chaque attribut à chaque fois que je crée un nouvel objet? +
Je dois alors créer un autre constructeur qui accepte les *arguments positionnels*.

[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
  has $.sexe;
  has $.nationalité;
  #nouveau constructeur qui prime sur constructeur par défaut.
  method new ($nom,$age,$sexe,$nationalité) {
    self.bless(:$nom,:$age,:$sexe,:$nationalité);
  }
}

my $françois = Human.new('François',23,'M','Sarthoise');
say $françois;
----
Le constructeur qui accepte arguments positionnels doit être définit comme ci-dessus.

=== Méthodes

==== Introduction
Les méthodes sont les _sous-programmes_ d'un objet. +
Comme les sous-programmes, elles sont un moyen d'empaqueter une collection de fonctionnalités, elles acceptent des *arguments*, ont une *signature* et peuvent être définies comme *multi*.

Les méthodes sont définies en utilisant le mot-clef `method`. +
Dans leur usage courant, les méthodes sont requises pour effectuer une action sur les attributs des objets.
Ce qui applique l'idée d'encapsulation. Les attributs des objets ne peuvent être manipulés qu'à l'intérieur de l'objet en utilisant des méthodes.
L'environement extérieur ne peut interargir avec l'objet qu'à travers ses méthodes, et n'a pas accès à ses attributs.

[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
  has $.sexe;
  has $.nationalité;
  has $.éligible;
  method confirme-éligibilité {
      if self.age < 21 {
        $!éligible = 'Non'
      } else {
        $!éligible = 'Oui'
      }
  }

}

my $françois = Humain.new(nom => 'John', age => 23, sexe => 'M', nationalité => 'Sarthoise');
$françois.confirme-éligibilité;
say $françois.éligible;
----

Une fois les méthodes définies dans une classe, elles peuvent être appelées sur un objet en utilisant le _point_: +
_objet_ *.* _méthode_ ou comme dans l'exemple ci-dessus: `$françois.confirme-éligibilité`

Dans la définition d'une méthode, si nous avons besoin de faire référence à l'objet en soi pour appeler une autre méthode, on utilise le mot-clef `self`. +

Dans la définition d'une méthode, si nous avons besoin de faire référence à un attribut, on utilise `!` même si il a été définit avec `.` +
La raison en est que le twigil `.` déclare un attribut avec `!` et automatise ensuite la création d'un accesseur.

Dans l'exemple ci dessus `if self.age < 21` et `if $!age < 21` auraient le même résultat, bien qu'ils techniquement différents:

* `self.age` appelle la méthode `.age` (accesseur) +
On peut aussi l'écrire `$.age`
* `$!age` est un appel direct à la variable

==== Méthodes Privées
Les méthodes normales peuvent être appelées sur des objets depuis l'extérieur de la classe.

Les *Méthodes Privées* sont des méthodes qui ne peuvent être appelées qu'à l'intérieur de la classe. +
Un cas possible d'usage serait une méthode qui en appelle une autre pour une action spécifique.
La méthode qui communique avec l'extérieur est publique alors celle qui est référencée doit rester privée.
Nous ne voulons par que les utilisateurs l'appellent directement, on la déclare donc comme privée.

La déclaration d'une méthode privée nécessite l'emploi du twigil `!` avant son nom. +
Les méthodes privées sont appelées avec `!` à la place de `.`

[source,perl6]
----
method !jesuisprivée {
  #du code ici
}

method jesuispublique {
  self!jesuisprivée;
  #faire d'autres choses
}
----

=== Attributs de Classe

Les *attributs de classe* sont des attributs qui appartiennent à la classe mais pas à ses objets. +
Ils peuvent être initialisés pendant la définition. +
Les attributs de classe sont déclarés en utilisant `my` au lieu de `has`. +
Ils sont appelés sur la classe elle même au lieu de ses objets.

[source,perl6]
----
class Humain {
  has $.nom;
  my $.compteur = 0;
  method new($nom) {
    Humain.compteur++;
    self.bless(:$nom);
  }
}
my $a = Humain.new('a');
my $b = Humain.new('b');

say Humain.counter;
----

=== Types d'accès
Jusqu'à présent, tous les exemples que nous avons vu utilisent des accesseurs pour obtenir des informations sur les attributs de l'objet.

Et si nous avons besoin de modifier la valeur d'un attribut. +
Nous devons pointer cet attribut comme _lisible/enregistrable_ en utilisant le mot-clef `is rw`
[source,perl6]
----
class Humain {
  has $.nom;
  has $.age is rw;
}
my $françois = Humain.new(nom => 'François', age => 21);
say $françois.age;

$françois.age = 23;
say $françois.age;
----
Par défaut, tous les attribut sont déclarés en _lecture seule_ mais vous pouvez aussi les déclarer explicitement avec `is readonly`

=== Hérirage
==== Introduction
L'*héritage* est un autre concept de la programmation orientéé objet.

Quand nous définissons des classes, on se rend compte que ces classes ont certains attributs/méthodes communs. +
Devons nous dupliquer le code. +
NON! Il est inpératif d'utiliser l'*héritage*.

Disons que nous voulons créer deux classes, une pour les humains et une pour les employés. +
Les Humains ont deux attributs: nom et age. +
Les Employés ont 4 attributs: nom, age, boite et salaire

On pourrait être tempté de définir les classes comme suit:
[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
}

class Employé {
  has $.nom;
  has $.age;
  has $.boite;
  has $.salaire;
}
----
Bien que correcte, la part de code ci-dessus est conceptuellement peu digeste.

Une meilleure approche serait:
[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
}

class Employé is Humain {
  has $.boite;
  has $.salaire;
}
----
Le mot-clef `is` définit l'héritage. +
Dans le Jargon orienté objet, on dit que Employé est un *enfant* de Humain, et Humain est un *parent* d'Employé.

Toutes les classes enfants héritent des attributs et des méthodes de la classe parente, il est donc inutile de les redéfinir.

==== Surcharge
Les classes héritent de tous les attributs et méthodes de leur classes parentes. +
Dans certains cas nous, avons besoin que la méthode d'un classe enfant se comporte différemment de celle dont elle hérite. +
Afin d'obtenir ce comportement, nous re-définisson la méthode dans la classe enfant. +
Ce concept est nommé *surcharge*.
Dans l'exemple ci-dessous, la classe Employé hérite de la méthode `présentez-vous`.

[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
  method présentez-vous {
    say "Bonjour je suis un être humain, et je m'appelle " ~ self.nom;
  }
}

class Employé is Humain {
  has $.boite;
  has $.salaire;
}

my $françois = Humain.new(nom =>'François', age => 23,);
my $anne = Employé.new(nom =>'Anne', age => 25, boite=> 'Acme', salaire => 2000);

$françois.présentez-vous;
$anne.présentez-vous;
----
La surcharge se fait comme ceci:

[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
  method présentez-vous {
    say "Bonjour je suis un être humain, et je m'appelle " ~ self.nom;
  }
}

class Employé is Humain {
  has $.boite;
  has $.salaire;
  method présentez-vous {
    "Bonjour je suis un être humain, et je m'appelle " ~ self.nom ~ ' et je travaille chez: ' ~ self.boite;
  }

}

my $françois = Humain.new(nom =>'François', age => 23,);
my $anne = Employé.new(nom =>'Anne', age => 25, boite=> 'Acme', salaire => 2000);

$françois.présentez-vous;
$anne.présentez-vous;
----

Suivant la classe dans laquelle se trouve l'objet, la bonne méthode sera appelée.

==== Sous-méthodes
Les *Sous-méthodes* sont un type de méthode dont les classes enfant n'héritent pas. +
Elles ne sont accessibles que depuis la classe dans laquelle elles sont déclarées. +
Elles sont déclarées en utilisant le mot-clef `submethod`.

=== Héritage Multiple
L'héritage multiple est disponible en Perl 6. Une classe peut hériter de plusieurs autres classes.

[source,perl6]
----
class barre-graph {
  has Int @.barre-valeurs;
  method dessiner {
    say @.barre-valeurs;
  }
}

class ligne-graph {
  has Int @.ligne-valeurs;
  method dessiner {
    say @.ligne-valeurs;
  }
}

class combo-graph is barre-graph is ligne-graph {
}

my $ventes-réelles = barre-graph.new(barre-valeurs => [10,9,11,8,7,10]);
my $ventes-prévisions = ligne-graph.new(ligne-valeurs => [9,8,10,7,6,9]);

my $réelles-vs-prévisions = combo-graph.new(barre-valeurs => [10,9,11,8,7,10],
                                            ligne-valeurs => [9,8,10,7,6,9]);
say "Ventes Réelles:";
$ventes-réelles.dessiner;
say "Ventes Prévisionelles:";
$ventes-prévisions.dessiner;
say "Réelles vs Prévisionelles:";
$réelles-vs-prévisions.dessiner;
----

.`Sortie`
----
Ventes Réelles:
[10 9 11 8 7 10]
Ventes Prévisionelles:
[9 8 10 7 6 9]
Réelles vs Prévisionelles:
[10 9 11 8 7 10]
----

.Explication
La classe `combo-graph` doit être capable de contenir 2 séries, une pour les valeurs réelles dessinées sous forme de barres
et une autre pour les valeurs prévisionelles dessinées sous forme de ligne. +
C'est pourquoi nous l'avons définit comme enfant de `ligne-graph` et `barre-graph` +
Vous avez remarqué que l'appel de la méthode `dessiner` sur `combo-graph` n'a pas rendu les bons résultats.

Une seule série a été dessinée. +
Que c'est-il passé. +
`combo-graph` hérite de `barre-graph` et de `ligne-graph`; et chaque parent possède un méthode appelée `dessiner`.
Quand nous appelons cette méthode sur `combo-graph` Perl 6 résoudra le conflit en appelant une des méthodes héritée.

.Correction
Pour avoir une comportement valide, nous devons surcharger la méthode `dessiner` dans `combo-graph`.

[source,perl6]
----
class barre-graph {
  has Int @.barre-valeurs;
  method dessiner {
    say @.barre-valeurs;
  }
}

class ligne-graph {
  has Int @.ligne-valeurs;
  method dessiner {
    say @.ligne-valeurs;
  }
}

class combo-graph is barre-graph is ligne-graph {
  method dessiner {
    say @.barre-valeurs;
    say @.ligne-valeurs;
  }
}

my $ventes-réelles = barre-graph.new(barre-valeurs => [10,9,11,8,7,10]);
my $ventes-prévisions = ligne-graph.new(ligne-valeurs => [9,8,10,7,6,9]);

my $réelles-vs-prévisions = combo-graph.new(barre-valeurs => [10,9,11,8,7,10],
                                            ligne-valeurs => [9,8,10,7,6,9]);
say "Ventes Réelles:";
$ventes-réelles.dessiner;
say "Ventes Prévisionelles:";
$ventes-prévisions.dessiner;
say "Réelles vs Prévisionelles:";
$réelles-vs-prévisions.dessiner;
----

.`Sortie`
----
Ventes Réelles:
[10 9 11 8 7 10]
Ventes Prévisionelles:
[9 8 10 7 6 9]
Réelles vs Prévisionelles:
[10 9 11 8 7 10]
----

=== Rôles
Les *rôles* sont assimilables à des classes, en ce sens qu'elles sont une collection de classes et de méthodes.

Les rôles sont déclarés avec le mot-clef `role`, les classes qui veulent implémenter un rôle peuvent le faire en utilisant le mot-clef `does`.

.Ré-écrivons l'exemple d'héritage multiple en utilisant des rôles:
[source,perl6]
----
role barre-graph {
  has Int @.barre-valeurs;
  method dessiner {
    say @.barre-valeurs;
  }
}

role ligne-graph {
  has Int @.ligne-valeurs;
  method dessiner {
    say @.ligne-valeurs;
  }
}

class combo-graph does barre-graph does ligne-graph {
  method dessiner {
    say @.barre-valeurs;
    say @.ligne-valeurs;
  }
}

my $ventes-réelles = barre-graph.new(barre-valeurs => [10,9,11,8,7,10]);
my $ventes-prévisions = ligne-graph.new(ligne-valeurs => [9,8,10,7,6,9]);

my $réelles-vs-prévisions = combo-graph.new(barre-valeurs => [10,9,11,8,7,10],
                                            ligne-valeurs => [9,8,10,7,6,9]);
say "Ventes Réelles:";
$ventes-réelles.dessiner;
say "Ventes Prévisionelles:";
$ventes-prévisions.dessiner;
say "Réelles vs Prévisionelles:";
$réelles-vs-prévisions.dessiner;
----

Si vous lancez le sript ci-dessus, vous constatez que les résultats sont les mêmes.

Vous vous demandez maintenant; si les rôles se comportent comme des classes, quelle est leur utilité? +
Pour répondre à votre question, modifiez le premier script utilisé pour illustrer l'héritage multiple,
celui où nous avons _oublié_ de surclasser la méthode `dessiner`.

[source,perl6]
----
role barre-graph {
  has Int @.barre-valeurs;
  method dessiner {
    say @.barre-valeurs;
  }
}

role ligne-graph {
  has Int @.ligne-valeurs;
  method dessiner {
    say @.ligne-valeurs;
  }
}

class combo-graph does barre-graph does ligne-graph {
}

my $ventes-réelles = barre-graph.new(barre-valeurs => [10,9,11,8,7,10]);
my $ventes-prévisions = ligne-graph.new(ligne-valeurs => [9,8,10,7,6,9]);

my $réelles-vs-prévisions = combo-graph.new(barre-valeurs => [10,9,11,8,7,10],
                                            ligne-valeurs => [9,8,10,7,6,9]);
say "Ventes Réelles:";
$ventes-réelles.dessiner;
say "Ventes Prévisionelles:";
$ventes-prévisions.dessiner;
say "Réelles vs Prévisionelles:";
$réelles-vs-prévisions.dessiner;
----

.`Sortie`
----
===SORRY!===
Method 'plot' must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)
----

.Explication
Si plusieurs rôles sont appliqués à la même classe, et un conflit survient, une erreur de compilation sera lancée. +
Ceci est une approche plus sûre que l'héritage multiple, où les conflits ne sont pas pris comme des erreurs et sont résolus à l'exécution.

Les rôles vous avertirons en cas de conflit.

=== Introspection
L'*introspection* sert à obtenir des informations sur les propriétés d'un objet: comme son type, ses attributs ou ses méthodes.

[source,perl6]
----
class Humain {
  has $.nom;
  has $.age;
  method présentez-vous {
    say "Bonjour je suis un être humain, et je m'appelle " ~ self.nom;
  }
}

class Employé is Humain {
  has $.boite;
  has $.salaire;
}

my $françois = Humain.new(nom =>'François', age => 23,);
my $anne = Employé.new(nom =>'Anne', age => 25, boite=> 'Acme', salaire => 2000);

$françois.présentez-vous;
$anne.présentez-vous;

say $françois.WHAT;
say $anne.WHAT;
say $françois.^attributes;
say $anne.^attributes;
say $françois.^methods;
say $anne.^methods;
say $anne.^parents;
if $anne ~~ Humain {say 'anne est un être humain'};
----
L'introspection est facilitée par:

* `.WHAT` renvoie la classe depuis laquelle l'objet a été créé.

* `.^attributes` renvoie une liste qui contient tous les attributs de l'objet.

* `.^methods` renvoie toutes les méthodes implémentables de l'objet.

* `.^parents` renvoie toutes les classes parentes auxquelles appartient l'objet.

* `~~` est appelé l'opérateur de correspondance intelligent (smart-match).
Il renvoie _Vrai_ si l'objet correspond à sa classe de création ou à une de celles dont elle a hérité.

== Gestion des exceptions

=== Capture des Exceptions
Les *exceptions* son un comportement particulier qui intervient quand quelquechose se passe mal à l'execution. +
On dit que les exceptions sont _lancées_.

Le script ci dessous, qui s'execute correctement:

[source,perl6]
----
my Str $nom;
$nom = "Josiane";
say "Bonjour " ~ $nom;
say "Comment ça va?"
----

.`Sortie`
----
Bonjour Josiane
Comment ça va?
----

Maintenant, le même script qui lance une exception:

[source,perl6]
----
my Str $nom;
$nom = 123;
say "Bonjour " ~ $nom;
say "Comment ça va?"
----

.`Sortie`
----
Type check failed in assignment to $name; expected Str but got Int
   in block <unit> at exceptions.pl6:2
----

Vous remarquerez que quand une erreur survient (ici assigner un nombre à une chaîne), le programme s'arrête et les lignes suivantes ne seront pas évaluées; même si elles sont correctes.

La *gestion des exceptions* _capture_ une exception qui a été _lancée_ afin que le script puisse continuer à fonctionner.

[source,perl6]
----
my Str $nom;
try {
  $nom = 123;
  say "Hello " ~ $nom;
  CATCH {
    default {
      say "Pouvez vous nous redonner votre nom, nous ne l'avous pas trouvé dans le registre.";
    }
  }
}
say "Comment ça va?";
----

.`Sortie`
----
Pouvez vous nous redonner votre nom, nous ne l'avous pas trouvé dans le registre.
Comment ça va?
----

La gestion d'axception se fait en utilisant un bloc `try-catch`.

[source,perl6]
----
try {
  #le code va ici
  #si quelquechose se passe mal les script entre dans le bloc CATCH
  #si tout se passe bien, le bloc CATCH sera ignoré
  CATCH {
    default {
      #le code présent ici ne sera évalué que si une exception a été lancée
    }
  }
}
----

Un bloc `CATCH` peut se définir de la même façon qu'un bloc `given`. 
Ce qui implique qu'on puisse faire un _catch_ sur différent types d'exceptions.

[source,perl6]
----
try {
  #le code va ici
  #si quelquechose se passe mal les script entre dans le bloc CATCH
  #si tout se passe bien, le bloc CATCH sera ignoré
  CATCH {
    when X::AdHoc { #faire quelquechose si une exception de type X::AdHoc est lancée }
    when X::IO { #faire quelquechose si une exception de type X::IO est lancée }
    when X::OS { #faire quelquechose si une exception de type X::OS est lancée }
    default { #faire quelquechose si une exception est lancée qui ne correspond pas aux types précédents }
  }
}
----

=== Lancer des Exceptions

A l'inverse de capturer les exceptions, Perl 6 vous permet aussi d'en lancer. +
On peut lancer deux types d'exceptions:

* les exceptions ad-hoc

* les exceptions typées

[source,perl6]
.ad-hoc
----
my Int $age = 21;
die "Erreur !";
----

[source,perl6]
.typed
----
my Int $age = 21;
X::AdHoc.new(payload => 'Erreur !').throw;
----

Les exceptions ad-hoc sont lancées en utilisant le sous-programme `die` suivit du message de l'exception.

Les exceptions Typées sont des objets, d'où l'utilisation du constructeur `.new()` dans l'exemple ci-dessus. +
Toutes les exceptions déscendent de la classe `X`, quelques exemples ci-dessous: +
`X::AdHoc` est le type le plus simple d'exception +
`X::IO` est liée aux erreurs IO (Entrée/sortie) +
`X::OS` est liée aux erreurs OS (Système) +
`X::Str::Numeric` est liée aux erreurs de conversion d'une chaîne vers un nombre

NOTE: Pour une liste complète des types d'exceptions et une liste de leurs méthodes associées, allez sur http://doc.perl6.org/type.html et naviguez dans les types qui commencent par X.



