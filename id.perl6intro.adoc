= Perkenalan Bahasa Pemrograman Perl 6 
Naoum Hankache <naoum@hankache.com>; Heince Kurniawan <heince@cpan.org>
:description: Pengenalan secara umum untuk bahasa pemrograman Perl 6
:keywords: perl6, perl 6, introduction, perl6intro, perkenalan perl 6, perl 6 tutorial, perl 6 intro
:Revision: 1.0
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:doctype: book
:lang: id


Dokumen ini dimaksudkan untuk memberikan gambaran secara umum dari bahasa pemrograman Perl 6.
Bagi anda yang baru pada pemrograman Perl 6, dokumen ini diharapkan dapat memberikan informasi yang cukup dan bahan untuk memulai.

Beberapa bagian dari dokumen ini merujuk ke http://docs.perl6.org[tautan resmi dokumentasi Perl 6] dimana tautan yang dirujuk lebih lengkap dan akurat..
Anda diharapkan untuk merujuk kesana bila memerlukan informasi lebih spesifik dari subjek tertentu.

Melalui dokumen ini, anda akan menemukan beberapa contoh untuk topik yang banyak dibahas.
Agar lebih dapat dimengerti, luangkan waktu untuk mencoba semua contoh yang diberikan.

.Lisensi
Karya ini dilisensikan oleh the Creative Commons Attribution-ShareAlike 4.0 International License.
Untuk melihat salinan lisensi ini, kunjungi

* https://creativecommons.org/licenses/by-sa/4.0/.

.Kontribusi
Apabila anda ingin berkontribusi dalam dokumen ini, kunjungi:

* https://github.com/hankache/perl6intro

.Saran
Kirimkan saran anda ke:
* naoum@hankache.com    - Bahasa Inggris
* heince@cpan.org       - Bahasa Indonesia

:sectnums:
== Perkenalan
=== Apa itu Perl 6
Perl 6 adalah bahasa pemrograman tingkat tinggi yang bersifat umum/non-spesifik dan data type variable ataupun ekspresi dapat dideklarasikan secara statis maupun dinamis. 
Perl 6 mendukung beberapa paradigma (teknis penyelesain masalah), antara lain : Pemrograman secara Prosedural, Berorientasi Objek, dan Fungsional.
* https://id.wikipedia.org/wiki/Pemrograman_Prosedural
* https://id.wikipedia.org/wiki/Pemrograman_berorientasi_objek
* https://id.wikipedia.org/wiki/Pemrograman_Fungsional

.Perl 6 moto:
* TMTOWTDI (dibaca "Tim Toady"): There is more than one way to do it (Ada lebih dari satu cara untuk melakukan sesuatu).
* Hal-hal yang mudah harus tetap mudah, hal-hal yang sulit harus menjadi lebih mudah, dan hal-hal yang tidak mungkin menjadi sulit.

=== Istilah Khusus
* *Perl 6*: Spesifikasi bahasa pemrograman dengan rangkain test.
Implementasi yang lulus uji spesifikasi dari rangkaian test dianggap Perl 6.
* *Rakudo*: Kompilator (compiler - https://id.wikipedia.org/wiki/Kompilator) untuk Perl 6.
* *Rakudobrew*: program untuk mengelola instalasi Rakudo.
* *Zef*: program untuk mengelola instalasi modul dari Perl 6.
* *Rakudo Star*: Bundel program yang terdiri dari Rakudo, Zef, koleksi beberapa modul Perl6 dan dokumentasi.

=== Cara Instalasi Perl 6
.Linux

Untuk menginstall "Rakudo Star", jalankan perintah berikut diterminal anda:
----
wget https://rakudo.perl6.org/downloads/star/rakudo-star-2018.01.tar.gz
tar xfz rakudo-star-2018.01.tar.gz
cd rakudo-star-2018.01
perl Configure.pl --gen-moar --prefix /opt/rakudo-star-2018.01
make install
----
Untuk metode instalasi lainnya, kunjungi http://rakudo.org/how-to-get-rakudo/#Installing-Rakudo-Star-Linux

.macOS
Ada 4 pilihan metode instalasi yang tersedia:

* Lakukan langkah-langkah yang sama sesuai cara instalasi Linux
* Instalasi dengan program homebrew (https://brew.sh): `brew install rakudo-star`
* Instalasi dengan program MacPorts (https://www.macports.org): `sudo port install rakudo`
* Unduh program installer terakhir (dengan file ekstensien .dmg) dari https://rakudo.perl6.org/downloads/star/

.Windows
. Unduh program installer terakhir (dengan file ekstensien .msi, pilih sesuai arsitektur sistem) dari https://rakudo.perl6.org/downloads/star/
. Setelah instalasi, pastikan `C:\rakudo\bin` terdeklarasi di PATH(variabel yang dipakai dilingkungan sistem operasi) 
. Tes dengan menjalankan perintah `perl6 -v` dicommand line prompt untuk verifikasi versi.

.Docker
. Unduh dari tautan resmi `docker pull rakudo-star`
. Kemudian jalankan container dengan perintah `docker run -it rakudo-star`

=== Menjalankan kode Perl 6

Menjalankan program / kode Perl 6 dapat dilakukan melalui REPL(Read-Eval-Print Loop). 
Caranya, buka program terminal, ketik `perl6` kemudian tekan tombol [Enter]. 
Tanda / karakter '>' akan muncul. 
Selanjutnya, ketik kode yang mau dijalankan dan tekan tombol [Enter].
REPL akan mencetak keluaran nilai dari kode yang diproses. 
Anda dapat menulis kode lainnya dibaris yang baru atau ketik `exit` dan tekan enter untuk keluar dari REPL.

Cara lainnya, ketik kode di file, simpan, dan jalankan menggunakan file tersebut. 
Direkomendasikan bahwa file script Perl 6 menggunakan ekstensien `.pl6`. 
Jalankan file script tersebut melalui terminal, ketik `perl6 namafileyangdisimpan.pl6`, kemudian tekan tombol [Enter]. 
Berbeda dengan metode REPL, cara ini tidak akan secara otomatis mencetak hasil tiap baris: kode harus menyertakan fungsi `say` untuk mengeluarkan cetakan hasil kode.

Metode REPL kebanyakan dipakai untuk mencoba spesifik bagian dari kode, biasanya program yang hanya berisi 1 baris. 
Untuk program yang membutuhkan kode lebih dari 1 baris, direkomendasikan untuk menyimpan kode kedalam file untuk kemudian diproses.

Program yang hanya membutuhkan 1 baris dapat juga menggunakan command line dengan mengetikkan `perl6 -e 'kode anda disini'` diterminal dan tekan [Enter].

[SARAN]
--
Apabila anda menginstall Rakudo bukan "Rakudo Star", direkomendasikan untuk menginstall modul tambahan berikut ini (Ketik didalam terminal):

* `zef install Linenoise` bila menggunakan Windows, Linux and macOS

* `zef install Readline`  Apabila anda menggunakan Linux, modul ini lebih direkomendasikan
--

=== Teks Editor
Karena sebagian waktu kita digunakan untuk menulis kode dan menyimpannya dalam file, sebaiknya kita menggunakan teks editor yang dapat mengenali sintaks Perl 6. 

Saya menggunakan dan merekomendasi https://atom.io/[Atom]. 
Atom adalah teks editor yang modern dan mempunyai fitur untuk mengenali dan menyorot sintaks Perl 6. 
https://atom.io/packages/language-perl6[Perl 6 FE] adalah alternatif sintaks highlight(direpresentasikan dengan penekanan warna) untuk Perl 6, 
diturunkan dari paket original tetapi disertai dengan perbaikan bug (https://id.wikipedia.org/wiki/Kekutu) dan fitur tambahan.

Sebagian orang dikomunitas juga menggunakan http://www.vim.org/[Vim], https://www.gnu.org/software/emacs/[Emacs] or http://padre.perlide.org/[Padre]. 

Versi baru dari Vim disertai dengan sintaks highlight. Sedangkan Emacs dan Padre membutuhkan paket tambahan untuk mendukung hal tersebut. 


=== Hello World!
Mari kita mulai dengan ritual `hello world`.

[source,perl6]
say 'hello world';

Dapat juga ditulis seperti:

[source,perl6]
'hello world'.say;

=== Gambaran ikhtisar dari Sintaks
Sintaks Perl 6 memiliki bentuk yang bebas: Dalam artian posisi karakter dibaris maupun kolom dikode anda tidak mempunyai efek yang signifikan.  
Contohnya Anda bebas untuk menggunakan karakter spasi dibagian manapun, walaupun pada kasus tertentu, spasi mengandung arti bagi Perl 6.

*Pernyataan* adalah kumpulan perintah kode, harus diakhiri dengan karakter titik koma:
`say "Hello" if True;`

*Ekspresi* adalah salah satu tipe bagian dari pernyataan yang mengembalikan suatu nilai:
`1+2` akan mengembalikan nilai `3`

Ekspresi adalah kombinasi dari 'Terms' (suatu nilai / variabel) dan "penghubung"(operator).

*Terms* adalah:

* *Variabel*: Wadah untuk menyimpan suatu nilai yang dapat digunakan dan dimodifikasi.

* *notasi*: Suatu tetapan nilai seperti angka atau kumpulan karakter (strings).

*Operator* dibagi menjadi beberapa tipe:

|===

| *Tipe* | *Penjelasan* | *Contoh*

| Prefix | sebelum 'terms' | `++1`

| Infix | diantara 'terms' | `1+2`

| Postfix | setelah 'terms' | `1++`

| Circumfix | sekeliling 'terms' | `(1)`

| Postcircumfix | setelah satu 'term', disekitar yang lain  | `Array[1]`

|===

==== Identifiers
Identifiers adalah penamaan yang diberikan / didefinisikan kepada 'terms' contohnya nama variabel.

.Syarat:
* Harus dimulai dengan karakter alfabetis atau garis bawah `_`.

* Dapat memakai angka (kecuali karakter pertama).

* Dapat memakai tanda garis `-` atau apostrof `'` (kecuali karakter pertama dan terakhir), harus diikuti karakter alfabetis setelah tanda garis maupun apostrof.

|===

| *Valid* | *Tidak valid*

| `var1` | `1var`

| `var-one` | `var-1`

| `var'one` | `var'1`

| `var1_` | `var1'`

| `_var` | `-var`

|===

.Kaidah Penamaan:
* Camel case: `variableNo1`

* Kebab case: `variable-no1`

* Snake case: `variable_no1`

Anda bebas untuk memilih penamaan dari identifier, tetapi disarankan untuk mengadopsi satu kaidah penamaan secara konsisten.

Penggunaan nama yang mempunyai arti akan mempermudah anda atau orang lain dalam dunia koding.

* `var1 = var2 * var3` secara sintaks benar tetapi tujuannya kurang jelas.
* `gaji-bulan-ini = gaji-perhari * jumlah-hari-kerja` penamaan ini akan lebih baik untuk penamaan variabel.

==== Komentar
Komentar adalah teks yang tidak dibaca oleh kompiler dan digunakan sebagai catatan.

Komentar dibagi menjadi 3 tipe:

* Satu baris:
+
[source,perl6]
# Ini adalah contoh komentar satu baris

* Tertanam (Embedded):
+
[source,perl6]
say #`(Ini adalah contoh komentar tertanam) "Hello World."

* Lebih dari satu baris (multi):
+
[source,perl6]
-----------------------------
=begin komentar
Ini adalah contoh komentar lebih dari satu baris
Komentar 1
Komentar 2
=end komentar
-----------------------------

==== Tanda Kutip
String harus dipisah dengan tanda kutip ganda `"..."` atau tunggal `'...'`.
* https://id.wikipedia.org/wiki/String

Selalu gunakan tanda kutip ganda:

* Jika string mengandung apostrop `'`

* Jika string mengandung variabel yang perlu diinterpolasi

[source,perl6]
-----------------------------------
say 'Hello World';   # Hello World
say "Hello World";   # Hello World
say "Don't";         # Don't
my $name = 'Wiro Sableng';
say 'Hello $name';   # Hello $name
say "Hello $name";   # Hello Wiro Sableng
-----------------------------------

== Operator

=== Jenis Operator Yang Umum
Dibawah ini adalah tabel dari Operator yang umum dipakai.
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Operator | Tipe | Deskripsi | Contoh | Hasil

| + | Infix | Penambahan | 1 + 2 | 3

| - | Infix | Pengurangan | 3 - 1 | 2

| * | Infix | Perkalian | 3 * 2 | 6

| ** | Infix | Pangkat | 3 ** 2 | 9

| / | Infix | Pembagian | 3 / 2 | 1.5

| div | Infix | Pembagian Integer (dibulatkan kebawah) | 3 div 2 | 1

| % | Infix | Modulus (sisa hasil bagi)| 7 % 4 | 3

.2+| %% .2+| Infix .2+| Divisibility (apakah mungkin untuk dibagi habis) | 6 %% 4 | False

<| 6 %% 3 <| True

| gcd | Infix | Greatest common divisor (nilai terbesar yang dapat membagi habis) | 6 gcd 9 | 3

| lcm | Infix | Least common multiple (kelipatan persekutuan terkecil) | 6 lcm 9 | 18

| == | Infix | Numeric equal (Perbandingan Numerik yang sama) | 9 == 7  | False

| != | Infix | Numeric not equal (Perbandingan Numerik yang tidak sama) | 9 != 7  | True

| < | Infix | Less than (lebih kecil dari) | 9 < 7  | False

| > | Infix | Greater than (lebih besar dari) | 9 > 7  | True

| \<= | Infix | Less than or equal (lebih kecil atau sama dengan) | 7 \<= 7  | True

| >= | Infix | Greater than or equal (lebih besar atau sama dengan) | 9 >= 7  | True

| eq | Infix | String equal (Perbandingan string sama dengan) | "John" eq "John"  | True

| ne | Infix | String not equal (Perbandingan string tidak sama dengan) | "John" ne "Jane"  | True

| = | Infix | Assignment (memberikan suatu nilai) | my $var = 7  | memberikan nilai `7` ke variabel `$var`

.2+| ~ .2+| Infix .2+| merangkai / menyambungkan String | 9 ~ 7 | 97

<m| "Hi " ~ "there"  <| Hi there

.2+| x .2+| Infix .2+| Replikasi String | 13 x 3  | 131313

<| "Hello " x 3  <| Hello Hello Hello

.5+| ~~ .5+| Infix .5+| Smart match (perbandingan pintar) | 2 ~~ 2  | True

<| 2 ~~ Int <| True

<| "Perl 6" ~~ "Perl 6" <| True

<| "Perl 6" ~~ Str <| True

<| "enlightenment" ~~ /light/ <| ｢light｣

.2+| ++ | Prefix | Increment (kenaikan / tambahan) | my $var = 2; ++$var;  | menambah variable + 1 dan mengembalikan nilai `3`

<m| Postfix <d| Increment <m| my $var = 2; $var++;  <| mengembalikan nilai variabel `2` kemudian menambah variabel + 1

.2+|\--| Prefix | Decrement | my $var = 2; --$var;  | mengurangi nilai variabel - 1 dan mengembalikan nilai menjadi `1`

<m| Postfix <d| Decrement <m| my $var = 2; $var--;  <| mengembalikan nilai variabel `2` kemudian  then mengurangi variabel -1

.3+| + .3+| Prefix .3+| merubah nilai menjadi nilai numerik | +"3"  | 3

<| +True <| 1

<| +False <| 0

.3+| - .3+| Prefix .3+| merubah nilai menjadi nilai numerik dan mengembalikan hasil sebaliknya | -"3"  | -3

<| -True <| -1

<| -False <| 0

.6+| ? .6+| Prefix .6+| merubah nilai menjadi nilai boolean (tipe data yang hanya mempunyai 2 nilai antara benar(True) atau salah(False)) | ?0 | False

<| ?9.8 <| True

<| ?"Hello" <| True

<| ?"" <| False

<| my $var; ?$var; <| False

<| my $var = 7; ?$var; <| True

| ! | Prefix | merubah nilai menjadi nilai boolean dan mengembalikan hasil sebaliknya | !4 | False

| .. | Infix | Range Constructor (pembangun rentang nilai) |  0..5  | membuat rentang nilai dari 0 sampai 5

| ..^ | Infix | Range Constructor |  0..^5  | membuat rentang nilai dari 0 sampai 4

| ^.. | Infix | Range Constructor |  0^..5  | membuat rentang nilai dari 1 sampai 5

| \^..^ | Infix | Range Constructor |  0\^..^5  | membuat rentang nilai dari 1 sampai 4

| ^ | Prefix | Range Constructor |  ^5  | sama seperti 0..^5 membuat rentang nilai dari 0 sampai 4

| ... | Infix | Lazy List Constructor |  0...9999  |  mengembalikan elemen hanya jika diminta

.2+| {vbar} .2+| Prefix .2+| Flattening (perataan) | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

=== Reversed Operators (Operator terbalik)

Penambahan karakter `R` sebelum operator akan membalikkan operand (https://id.wikipedia.org/wiki/Operand)

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Pengoperasian Normal | Hasil | Reversed Operator | Hasil

| 2 / 3 | 0.666667 | 2 R/ 3 | 1.5

| 2 - 1 | 1 | 2 R- 1 | -1

|===

=== Reduction Operators (Operator spesial yang digunakan untuk mengurangi elemen array / list menjadi satu nilai)

Reduction operators dapat berjalan di rangkaian atau daftar suatu nilai.
Dibentuk oleh kurung kotak buka dan tutup `[]`

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Perngoperasian Normal | Hasil | Reduction Operator | Hasil

| 1 + 2 + 3 + 4 + 5 | 15 | [+] 1,2,3,4,5 | 15

| 1 * 2 * 3 * 4 * 5 | 120 | [*] 1,2,3,4,5 | 120

|===

CATATAN: Untuk mengetahui operator lainnya termasuk tata cara penggabungan atau susunannya, kunjungi https://docs.perl6.org/language/operators

== Variabel
Variabel dari Perl6 diklasifikasian menjadi 3 kategori: Scalars, Arrays dan Hashes.

Karakter *sigil* (Sign in Latin) adalah karakter yang digunakan sebagai awalan untuk mengkategorikan variabel.

* karakter `$` digunakan untuk scalars
* karakter `@` digunakan untuk arrays
* karakter `%` digunakan untuk hashes

=== Scalars
Scalar menampung satu nilai atau referensi.

[source,perl6]
----
# String
my $nama = 'Wiro Sableng';
say $nama;

# Integer
my $umur = 99;
say $umur;
----

Suatu set pengoperasian tertentu dapat dilakukan di scalar, tergantung dari nilai yang ditampung.

[source,perl6]
.String
----
my $nama = 'Wiro Sableng';
say $nama.uc;
say $nama.chars;
say $nama.flip;
----

----
WIRO SABLENG
12
gnelbaS oriW
----

CATATAN: Untuk melihat metode yang lebih lengkap dan dapat diaplikasikan pada String, kunjungi https://docs.perl6.org/type/Str

[source,perl6]
.Integer
----
my $umur = 17;
say $umur.is-prime;
----

----
True
----

CATATAN: Untuk melihat metode yang lebih lengkap dan dapat diaplikasikan pada Integer, kunjungi https://docs.perl6.org/type/Int

[source,perl6]
.Rational Number (https://id.wikipedia.org/wiki/Bilangan_rasional)
----
my $umur = 2.3;
say $umur.numerator;
say $umur.denominator;
say $umur.nude;
----

----
23
10
(23 10)
----

CATATAN: Untuk melihat metode yang lebih lengkap dan dapat diaplikasikan pada Bilangan Rasional, kunjungi https://docs.perl6.org/type/Rat

=== Arrays
Arrays adalah daftar yang dapat berisi lebih dari satu nilai.

[source,perl6]
----
my @hewan = 'ayam','bebek','burung';
say @hewan;
----

Banyak pengoperasian dapat dilakukan pada arrays seperti contoh dibawah:

Saran: karakter tilde  `~` digunakan untuk menggabungkan string.

[source,perl6]
.`Script`
----
my @hewan = 'harimau','gajah','panda';
say "Di kebun binatang ada " ~ @hewan.elems ~ " hewan";
say "Hewannya antara lain: " ~ @hewan;
say "Kebun binatang akan mengadopsi gorila";
@hewan.push("gorila");
say "Sekarang kebun binatang mempunyai hewan: " ~ @hewan; 
say "Hewan pertama yang diadopsi adalah " ~ @hewan[0];
@hewan.pop;
say "Sayangnya gorilanya kabur dan yang tersisa: " ~ @hewan;
say "Kebun binatang akan ditutup dan hanya akan mempertahankan 1 hewan saja";
say "Kebun binatang akan melepas: " ~ @hewan.splice(1,2) ~ " dan mempertahankan " ~ @hewan;
----

.`Output` (Hasil Keluaran)
----
Di kebun binatang ada 3 hewan
Hewannya antara lain: harimau gajah panda
Kebun binatang akan mengadopsi gorila
Sekarang kebun binatang mempunyai hewan: harimau gajah panda gorila
Hewan pertama yang diadopsi adalah harimau
Sayangnya gorilanya kabur dan yang tersisa: harimau gajah panda
Kebun binatang akan ditutup dan hanya akan mempertahankan 1 hewan saja
Kebun binatang akan melepas: gajah panda dan mempertahankan harimau
----

.Penjelasan
`.elems` mengembalikan nilai dari jumlah elemen dalam suatu array. +
`.push()` menambahkan satu atau lebih elemen kedalam array. +
Kita dapat mengakses spesifik elemen array dengan menspesifikasian posisinya `@hewan[0]`. +
`.pop` menghapus elemen terakhir dari array dan mengembalikan elemen yang dihapus. +
`.splice(a,b)` menghapus elemen `b` dimulai dari posisi `a`.

==== Fixed-size arrays (array yang berukuran tetap)
Secara dasar, array dideklarasikan sebagai berikut:
[source,perl6]
my @array;

Array dapat mempunyai ukuran tak terbatas dan karenanya disebut auto-extending(diperpanjang otomatis). +
Array dapat menerima suatu nilai tanpa batasan.

Sebaliknya, kita dapat juga membuat array dengan ukuran yang tetap. +
Array ini tidak dapat diakses diluar atau melebihi ukuran yang ditetapkan.

Untuk mendeklarasi array dengan ukuran tetap, spesifikasikan jumlah maksimum elemen di kurung kotak setelah penamaan variabelnya:
[source,perl6]
my @array[3];

Array ini akan dapat menampung maksimum 3 nilai, terindeks dari 0 sampai 2.

[source,perl6]
----
my @array[3];
@array[0] = "nilai pertama";
@array[1] = "nilai kedua";
@array[2] = "nilai ketiga";
----

Anda tidak dapat menambah nilai keempat kedalam array ini:
[source,perl6]
----
my @array[3];
@array[0] = "nilai pertama";
@array[1] = "nilai kedua";
@array[2] = "nilai ketiga";
@array[3] = "nilai keempat";
----

----
Index 3 for dimension 1 out of range (must be 0..2)
----

==== Multidimensional arrays
Array yang kita demonstrasikan diatas adalah array dengan 1 dimensi. +
Kita juga dapat mendefinisikan array multi dimensi.

[source,perl6]
my @tabel[3;2];

Ini adalah array dengan 2 dimensi.
Dimensi pertama dapat mempunyai maksimal 3 nilai dan dimensi yang kedua dapat mempunyai maksimal 2 nilai.

Dapat diilustrasikan seperti tabel 3x2.

[source,perl6]
----
my @tabel[3;2];
@tabel[0;0] = 1;
@tabel[0;1] = "x";
@tabel[1;0] = 2;
@tabel[1;1] = "y";
@tabel[2;0] = 3;
@tabel[2;1] = "z";
say @tabel;
----

----
[[1 x] [2 y] [3 z]]
----

.Representasi visual dari array:
----
[1 x]
[2 y]
[3 z]
----

CATATAN: Untuk lebih lengkapnya tentang referensi Array, kunjungi https://docs.perl6.org/type/Array

=== Hashes
[source,perl6]
.Hash adalah kumpulan dari satu atau lebih pasangan kata kunci dan nilainya.
----
my %ibukota = ('UK','London','Indonesia','Jakarta');
say %ibukota;
----

[source,perl6]
.Cara lain dalam mengisi nilai hash:
----
my %ibukota = (UK => 'London', Indonesia => 'Jakarta');
say %ibukota;
----

Beberapa metode yang dapat dipanggil dengan hash:
[source,perl6]
.`Script`
----
my %ibukota = (UK => 'London', Indonesia => 'Jakarta');
%ibukota.push: (Perancis => 'Paris');
say %ibukota.kv;
say %ibukota.keys;
say %ibukota.values;
say "Ibukota dari Perancis adalah: " ~ %ibukota<Perancis>;
----

.`Output`
----
(Perancis Paris UK London Indonesia Jakarta)
(Perancis UK Indonesia)
(Paris London Jakarta)
Ibukota dari Perancis adalah: Paris
----

.Penjelasan
`.push: (katakunci => 'nilai')` menambahkan pasangan kata kunci dan nilainya. +
`.kv` mengembalikan daftar nilai seluruh pasangan kata kunci dan nilainya. +
`.keys` mengembalikan daftar nilai seluruh kata kunci saja. +
`.values` mengembalikan daftar nilai seluruh nilai dari kata kunci saja. +
Kita dapak mengakses nilai spesifik dari kata kunci tertentu dengan `%hash<katakunci>`

CATATAN: Untuk referensi lengkap Hash, kunjungi https://docs.perl6.org/type/Hash

=== Types
Dicontoh sebelumnya, kita tidak menspesifikasi tipe nilai dari suatu variabel.

SARAN: `.WHAT` akan mengembalikan tipe nilai yang disimpan dalam variabel.

[source,perl6]
----
my $var = 'Text';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
----

Contoh diatas menunjukkan awalnya tipe nilai dari `$var` adalah (Str) kemudian berubah menjadi (Int).

Gaya koding seperti ini disebut dynamic typing. Dinamis dalam artian suatu variable dapat menampung segala tipe nilai.

Sekarang coba untuk menjalankan contoh dibawah: +
Perhatikan `Int` sebelum nama variabel.

[source,perl6]
----
my Int $var = 'Text';
say $var;
say $var.WHAT;
----

Contoh diatas akan gagal dan mengembalikan pesan eror: `Type check failed in assignment to $var; expected Int but got Str`

Apa yang terjadi adalah kita menspesifikasikan kalau variable tersebut nilainya harus berupa tipe (Int).
Ketika kita mencoba untuk memberikan nilai berupa (Str), kode tersebut akan gagal.

Gaya koding ini disebut static typing. Statis dalam artian tipe nilai variabel didefinisikan sebelumnya dan tidak dapat dirubah.

Perl 6 diklasifikasikan sebagai *gradually typed*; Memperbolehkan gaya statis dan dinamis.

.Arrays dan hashes dapat juga dideklarasikan secara statis:
[source,perl6]
----
my Int @array = 1,2,3;
say @array;
say @array.WHAT;

my Str @multilingual = "Hello","Salut","Hallo","您好","안녕하세요","こんにちは";
say @multilingual;
say @multilingual.WHAT;

my Str %ibukota = (Indonesia => 'Jakarta', UK => 'London', Germany => 'Berlin');
say %ibukota;
say %ibukota.WHAT;

my Int %kode-negara = (Indonesia => 62, UK => 44, Germany => 49);
say %kode-negara;
say %kode-negara.WHAT;
----

.Dibawah adalah daftar dari tipe yang sering dipakai:
Anda mungkin tidak akan pernah memakai dua tipe yang pertama, tipe tersebut dicantumkan untuk tujuan informasi.

[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Tipe* | *Deskripsi* | *Contoh* | *Hasil*

| Mu | Hirarki paling atas dari tipe Perl 6 | |

| Any | Default kelas dasar untuk kelas baru dan hampir semua kelas lainnya yang termasuk dalam Perl 6 | |

| Cool | Nilai yang dapat dianggap sebagai string atau numerik | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | String atau kumpulan dari karakter | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Integer (bilangan bulat) | 7 + 7 | 14

| Rat | Rational number (bilangan rational) | 0.1 + 0.2 | 0.3

| Bool | Boolean | !True | False

|===

=== Introspection (Introspeksi)

Introspection adalah proses untuk medapatkan informasi tentang properti suatu objek seperti tipe objek. +
Disalah satu contoh sebelumnya, kita menggunakan `.WHAT` untuk mengembalikan tipe dari variabel.

[source,perl6]
----
my Int $var;
say $var.WHAT;    # (Int)
my $var2;
say $var2.WHAT;   # (Any)
$var2 = 1;
say $var2.WHAT;   # (Int)
$var2 = "Hello";
say $var2.WHAT;   # (Str)
$var2 = True;
say $var2.WHAT;   # (Bool)
$var2 = Nil;
say $var2.WHAT;   # (Any)
----

Tipe dari suatu variabel yang menyimpan suatu nilai berkorelasi terhadap nilainya. +
Tipe dari suatu variabel kosong yang dideklarasikan adalah tipe dari yang mana dideklarasikan. +
Tipe dari suatu variable kosong yang tidak dideklarasikan adalah `(Any)` +
Untuk menhapus nilai dari suatu variabel, berikan `Nil` ke variabel tersebut.

=== Scoping (Ruang lingkup)
Sebelum menggunakan variabel, variabel perlu dideklarasikan.

Beberapa deklarator digunakan di Perl 6. Kita telah menggunakan `my` selama ini.

[source,perl6]
my $var=1;

Deklarator `my` declarator memberikan variabel ruang lingkup *lexical*.
Dengan kata lain, variabel cuma bisa diakses bila berada didalam blok dimana variabel dideklarasikan.

Suatu blok di Perl 6 dibatasi oleh `{  }`.
Jika blok tidak ditemukan, variabel akan bisa diakses diseluruh kode Perl 6.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;   # dapat diakses
}
say $var;   # bagian ini tidak dapat diakses, akan terdapat error
----

Karena sebuah variabel hanya dapat diakses diblok dimana variabel tersebut didefinisikan, nama variabel yang sama dapat digunakan diblok yang lain.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Assignment vs. Binding
Kita telah melihat dicontoh sebelumnya bagaimana untuk memberikan nilai ke variabel. +
Pemberian nilai (Assignment) dilakukan menggunakan operator `=`.
[source,perl6]
----
my Int $var = 123;
say $var;
----

Kita dapat mengubah nilai yang diberi pada suatu variabel:

[source,perl6]
.Assignment
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Output`
----
123
999
----

Disamping itu, kita tidak dapat merubah nilai yang *terikat* pada variabel. +
*Binding* atau pengikatan suatu nilai dilakukan menggunakan operator `:=`.

[source,perl6]
.Binding
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Output`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.Variabel dapat juga direferensikan kevariabel lainnya:
----
my $a;
my $b;
$b := $a;
$a = 7;
say $b;
$b = 8;
say $a;
----

.`Output`
----
7
8
----

Binding variabel (pengikatan pada variabel) bersifat 2 arah. +
`$a := $b` and `$b := $a` mempunyai efek yang sama.

CATATAN: Untuk informasi yang lebih lengkap tentang variabel, kunjungi https://docs.perl6.org/language/variables

== Fungsi dan Mutator

Penting untuk mengetahui perbedaan fungsi dan mutator. +
Fungsi tidak mengubah status dari objek atau variabel yang dipanggil / digunakan. +
Mutator memodifikasi status dari objek atau variabel.

[source,perl6,linenums]
.`Script`
----
my @numbers = [7,2,4,9,11,3];

@numbers.push(99);
say @numbers;      #1

say @numbers.sort; #2
say @numbers;      #3

@numbers.=sort;
say @numbers;      #4
----

.`Output`
----
[7 2 4 9 11 3 99] #1
(2 3 4 7 9 11 99) #2
[7 2 4 9 11 3 99] #3
[2 3 4 7 9 11 99] #4
----

.Penjelasan
`.push` adalah mutator karena merubah status dari array (#1)

`.sort` adalah fungsi karena mengembalikan nilai array yang telah diurutkan tetapi tidak mengubah status array seperti diawal:

* (#2) menunjukkan bahwa hasil output array yang telah diurutkan.

* (#3) menunjukkan bahwa array tidak termodifikasi, masih seperti status diawal.

Untuk memaksa fungsi menjadi mutator, kita gunakan `.=` sebagai pengganti `.` (#4) (Baris ke 9)

== Loops and conditions (pengulangan dan syarat / kondisi)
Perl6 mempunyai banyak sintaks atau cara untuk melakukan persyaratan dan pengulangan

=== if
Kode hanya akan berjalan apabila syarat atau kondisi tertentu dipenuhi, misalnya sebuah ekpresi yang mengembalikan nilai `True`.

[source,perl6]
----
my $umur = 19;

if $umur > 18 {
  say 'Selamat Datang';
}
----

Dalam Perl 6, kita dapat membalikkan susunan kode dan kondisinya. +
Bahkan bila kode dan kondisinya sudah dibalik, kondisi / syarat selalu akan dievaluasi terlebih dahulu.

[source,perl6]
----
my $umur = 19;

say 'Selamat Datang' if $umur > 18;
----

Jika syarat atau kondisi tidak terpenuhi, kita dapat menyertakan blok alternatif untuk mengeksekusinya dengan:

* `else`
* `elsif`

[source,perl6]
----
# Menjalankan kode yang sama dengan nilai variabel yang berbeda
my $jumlah-kursi = 9;

if $jumlah-kursi <= 5 {
  say 'mobil sedan'
} elsif $jumlah-kursi <= 7 {
  say 'mobil 7 kursi'
} else {
  say 'bis kota'
}
----

=== unless (kecuali)
Merupakan pernyataan negasi atau lawan statement dari `if`.

Kode berikut ini:

[source,perl6]
----
my $sepatu-bersih = False;

if not $sepatu-bersih {
  say 'Bersihkan sepatumu'
}
----
Dapat juga ditulis seperti:

[source,perl6]
----
my $sepatu-bersih = False;

unless $sepatu-bersih {
  say 'Bersihkan sepatumu'
}
----

Negasi dalam Perl 6 dilakukan dengan `!` atau `not`.

`unless (condition)` digunakan bukannya `if not (condition)`.

`unless` tidak dapat menggunakan statement / klausa `else`.

=== with

`with` hampir sama dengan pernyataan `if`, bedanya `with` mengecek apakah variabel terdefinisi.

[source,perl6]
----
my Int $var=1;

with $var {
  say 'Hello'
}
----

Apabila variabel tidak diberikan suatu nilai, tidak akan ada output.
[source,perl6]
----
my Int $var;

with $var {
  say 'Hello'
}
----

`without` adalah versi negasi dari `with`. Hampir sama dengan analogi `unless` dengan `if`.

Jika kondisi pertama `with` tidak terpenuhi, alternatifnya dapat ditentukan dengan `orwith`. +
`with` dan `orwith` sama dengan hubungan antara `if` dan `elsif`.

=== for

Pernyataan `for` melakukan pengulangan terhadap kelipatan nilai.

[source,perl6]
----
my @array = [1,2,3];

for @array -> $array-item {
  say $array-item * 100
}
----

Kode diatas kita membuat sebuah array, kemudian kita melakukan pengulangan terhadap array tersebut, 
membuat variabel `$array-item` untuk menampung nilai dari tiap pengulangan, 
melakukan perkalian `*100` pada tiap item array, kemudian menampilkan hasil tiap perulangan.

=== given

`given` dalam Perl 6 hampir sama dengan pernyataan `switch` pada bahasa pemrograman lainnya,
tetapi lebih powerful.

[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Kurang dari atau sama dengan 50'}
    when Int { say "ini adalah Int" }
    when 42  { say 42 }
    default  { say "huh?" }
}
----

Proses perbandingan akan berhenti (tidak diteruskan keperbandingan selanjutnya) apabila ada yang sukses.

Apabila ingin lanjut keperbandingan selanjutnya, bisa menggunakan `proceed`.
[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Kurang dari atau sama dengan 50';proceed}
    when Int { say "ini adalah Int";proceed}
    when 42  { say 42 }
    default  { say "huh?" }
}
----

=== loop

`loop` adalah cara lain untuk menulis pengulangan `for`.

Sebenarnya, `loop` adalah bagaimana pengulangan `for` ditulis dalam bahasa pemrograman C.

Perl 6 tergolong didalam keluarga bahasa pemrograman C.

[source,perl6]
----
loop (my $i = 0; $i < 5; $i++) {
  say "nomor sekarang adalah $i"
}
----

CATATAN: Untuk informasi lebih lanjut tentang pengulangan dan pengkondisian, kunjungi https://docs.perl6.org/language/control

== I/O
Dalam Perl 6, dua antar muka yang sering dipakai adalah Terminal dan file.

=== Dasar I/O menggunakan Terminal

==== say
`say` menulis ke standard output. Ia menambah karakter baris baru diakhir. Dengan kata lain, kode dibawah:

[source,perl6]
----
say 'Hello Mam.';
say 'Hello Sir.';
----
Akan ditulis dalam 2 baris yang terpisah.

==== print
`print` hampir sama dengan `say` tetapi tidak menambahkan karakter baris baru diakhir.

Coba untuk mengganti `say` dengan `print` dan bandingkan keluaran hasilnya.

==== get
`get` digunakan untuk menangkap input dari terminal.

[source,perl6]
----
my $nama;

say "Hi, namanya siapa?";
$nama = get;

say "Halo $nama, selamat datang di Perl 6";
----

Ketika kode dijalankan, terminal akan menunggu input nama. Masukkan nama anda dan tekan tombol [Enter].

==== prompt
`prompt` adalah kombinasi dari `print` dan `get`.

Contoh diatas bisa juga ditulis seperti ini:

[source,perl6]
----
my $nama = prompt "Hi, nama anda siapa? ";

say "Dear $nama, selamat datang di Perl 6";
----

=== Running Shell Commands (Menjalankan program shell/terminal)

2 subroutines (https://id.wikipedia.org/wiki/Subrutin) dapat digunakan untuk menjalankan program shell:

* `run` menjalankan program external tanpa melibatkan shell

* `shell` menjalan program dengan melibatkan shell. Metode ini tergantung dari platform dan tipe shell yang digunakan.
Semua spesial karakter akan ditafsirkan oleh shell yang bersangkutan, termasuk pipes, redirection, pergantian environment variable dan lainnya.
Pipes adalah suatu teknik untuk memberikan informasi / output dari satu proses ke proses lainnya.
Redirection adalah suatu teknik mengalihkan input atau output suatu proses ke lokasi yang diinginkan oleh pengguna.
Environment variable adalah variabel yang mempengaruhi proses / program yang sedang berjalan, biasanya diset sebelum program berjalan dan dapat berubah
seiring jalannya program.

[source,perl6]
.Jalankan program dibawah apabila anda menggunakan sistem operasi Linux/macOS
----
my $nama = 'Neo';
run 'echo', "hello $nama";
shell "ls";
----

[source,perl6]
.Jalankan program dibawah apabila anda menggunakan sistem operasi Windows
----
shell "dir";
----
Perintah atau program `echo` dan `ls` adalah perintah shell yang umum pada sistem operasi Linux: +
Perintah `echo` mencetak keluaran teks pada terminal (hampir sama dengan fungsi `print` di Perl 6) +
Perintah `ls` mencetak daftar semua file dan direktori yang ada pada direktori yang sekarang. 

Perintah atau program `dir` sama dengan perintah `ls` di sistem operasi Windows.


=== File I/O
==== slurp
`slurp` digunakan untuk membaca data dari suatu file.

Buat sebuah file teks dengan isi sebagai berikut:

.datafile.txt
----
John 9
Johnnie 7
Jane 8
Joanna 7
----
[source,perl6]
----
my $data = slurp "datafile.txt";
say $data;
----

==== spurt
`spurt` digunakan untuk menulis data kedalam suatu file.

[source,perl6]
----
my $databaru = "Nilai baru:
Paul 10
Paulie 9
Paulo 11";

spurt "datafilebaru.txt", $databaru;
----

Setelah menjalankan kode diatas, file baru dengan nama _datafilebaru.txt_ akan terbuat. File tersebut akan berisi nilai baru.

=== Bekerja dengan file dan direktori
Perl 6 dapat memberikan daftar isi dari sebuah direktori tanpa menggunakan perintah shell (contohnya seperti perintah `ls`).

[source,perl6]
----
say dir;              # Mencetak daftar file dan direktori pada direktori yang sekarang
say dir "/Dokumen";   # Mencetak daftar file dan direktori pada direktory yang ditentukan
----

Anda juga dapat membuat dan meghapus direktori.

[source,perl6]
----
mkdir "folderbaru";
rmdir "folderbaru";
----

`mkdir` membuat direktori baru. +
`rmdir` menghapus direktori yang kosong dan mengembalikan error apabila direktori tidak kosong.

Anda juga dapat memeriksa jika suatu file atau direktori ada atau tidak:

Buat direktori baru `folder123` dan file kosong `script123.pl6`

[source,perl6]
----
say "script123.pl6".IO.e;
say "folder123".IO.e;

say "script123.pl6".IO.d;
say "folder123".IO.d;

say "script123.pl6".IO.f;
say "folder123".IO.f;
----

`IO.e` memeriksa jika file atau direktori ada. +
`IO.f` memeriksa jika file path adalah file. +
`IO.d` memeriksa jika file path adalah sebuah direktori.

PERINGATAN: Pengguna Windows dapat menggunakan `/` atau `\\` untuk mendefinisikan direktori +
`C:\\rakudo\\bin` +
`C:/rakudo/bin` +

CATATAN: Untuk informasi lanjut seputar I/O, kunjungi https://docs.perl6.org/type/IO

== Subroutines
=== Definisi
*Subroutines* (biasa disebut *subs* atau *functions) bertujuan untuk mengemas dan menggunakan kembali suatu fungsi. +

Sebuah definisi subroutine dimulai dengan kata kunci `sub`. 
Perhatikan contoh dibawah:

[source,perl6]
----
sub selamat-pagi {
  say "Hello, selamat pagi !";
}

selamat-pagi;
----

Contoh diatas menunjukkan sebuah subroutine yang tidak memerlukan suatu input.

=== Signature
Subroutine dapat mengharuskan suatu input. Input tersebut disediakan oleh *arguments*.
Suatu subroutine boleh tidak mendefinisikan atau mendefinisikan lebih dari satu *parameters*.
Jumlah dan tipe dari parameter tersebut dinamakan *signature*.

subroutine dibawah menerima argumen sebuah string.
The below subroutine accepts a string argument.

[source,perl6]
----
sub say-hello (Str $nama) {
    say "Hello " ~ $nama ~ "!!!!"
}
say-hello "Paul";
say-hello "Paula";
----

=== Multiple dispatch
Memungkinkan untuk mendefinisi lebih dari satu subroutine dengan mengunakan nama yang sama tetapi signature yang berbeda.
Ketika subroutine dipanggil, runtime akan memutuskan versi mana yang akan digunakan berdasarkan jumlah dan tipe dari argumen yang diterima.
Tipe subroutine seperti ini memerlukan kata kunci `multi` bukan `sub`.

[source,perl6]
----
multi selamat-pagi($nama) {
    say "Selamat Pagi $nama";
}
multi selamat-pagi($nama, $gelar) {
    say "Selamat Pagi $gelar $nama";
}

selamat-pagi "Johnnie";
selamat-pagi "Laura","Nyonya";
----

=== Default and Optional Parameters
Jika sebuah subroutine didefinisikan untuk menerima sebuah argumen dan dipanggil tanpa argumen, maka program tersebut akan gagal.

Perl 6 menyediakan kemampuan untuk mendefinisi subroutine dengan :

* Optional Parameters : argumen yang boleh ada atau tidak
* Default Parameters :  apabila argumen tidak diberikan, maka nilai default yang akan dipakai sebagai acuan

Optional parameters didefinisikan dengan menambah karakter `?` setelah penamaan parameter.

[source,perl6]
----
sub say-hello($nama?) {
  with $nama { say "Hello " ~ $nama }
  else { say "Hello Manusia" }
}
say-hello;
say-hello("Laura");
----

Jika tidak memberikan argumen, nilai default dapat didefinisikan. +
Ini dapat dilakukan dengan memberikan nilai pada parameter.

[source,perl6]
----
sub say-hello($nama="Matt") {
  say "Hello " ~ $nama;
}
say-hello;
say-hello("Laura");
----

=== Returning values
Semua contoh subroutine yang kita lihat melakukan suatu fungsi -- misalnya menampilkan teks pada terminal.

Terkadang, kita memanggil subroutine hanya untuk nilai yang dikembalikan *return value* agar kita dapat menggunakan nilai tersebut dialur program kita.

Apabila *return value* tidak ditulis secara implisit maka statement atau ekspresi terakhir yang akan menjadi *return value*.

[source,perl6]
.Implicit return
----
sub kuadrat ($x) {
  $x ** 2;
}
say "7 kuadrat = " ~ kuadrat(7);
----

Supaya lebih jelas, disarankan untuk secara eksplisit mendefinisikan nilai yang akan dikembalikan. 
Ini dapat dilakukan dengan kata kunci `return`.
[source,perl6]
.Explicit return
----
sub kuadrat ($x) {
  return $x ** 2;
}
say "7 kuadrat = " ~ kuadrat(7);
----
==== Restricting return values
Disalah satu contoh diatas, kita melihat bagaimana argumen yang diterima dapat dibatasi untuk tipe tertentu.
Begitupun dengan return values.

Untuk membatasi return value ke tipe tertentu, dapat menggunakan `returns` atau tanda panah `-\->` di signature.

[source,perl6]
.Penggunaan returns trait
----
sub kuadrat ($x) returns Int {
  return $x ** 2;
}
say "1.2 kuadrat = " ~ kuadrat(1.2);
----

[source,perl6]
.Penggunaan tanda panah
----
sub kuadrat ($x --> Int) {
  return $x ** 2;
}
say "1.2 kuadrat = " ~ kuadrat(1.2);
----
Jika return value tidak sesuai dengan tipe yang diharapkan, error akan terjadi.

----
Type check failed for return value; expected Int but got Rat (1.44)
----

[TIP]
====
Tipe constraints tidak hanya membatasi tipe dari return value tapi dapat juga mengontrol definisinya.

Dicontoh sebelumnya, kita menspesifikasi jika return value harus sebuah `Int`.

Kita dapat juga menentukan bahwa nilai `Int` yang dikembalikan harus terdefinisi atau tidak terdefinisi menggunakan signature berikut: +
`--> Int:D` dan `--> Int:U`

Sangat disarankan untuk menggunakan tipe constraints tersebut. +
Dibawah adalah versi modifikasi dari contoh sebelumnya yang memakai `:D` untuk memaksa nilai `Int` yang dikembalikan harus terdefinisi.

[source,perl6]
----
sub kuadrat ($x --> Int:D) {
  return $x ** 2;
}
say "1.2 kuadrat = " ~ kuadrat(1.2);
----
====

CATATAN: Untuk info lebih lanjut tentang subroutines dan functions, kunjungi https://docs.perl6.org/language/functions

== Functional Programming
https://id.wikipedia.org/wiki/Pemrograman_Fungsional
Dichapter ini kita akan melihat beberapa fitur yang mengfasilitasi Functional Programming.

=== Functions are first-class citizens
Functions/subroutines adalah warga negara kelas satu:

* dapat diberikan sebagai argumen

* dapat dikembalikan dari fungsi lain

* dapat diperuntukkan ke variabel

Contohnya fungsi `map`. +
`map` adalah  _higher order function_, ia dapat menerima fungsi lain sebagai argument.

[source,perl6]
.Script
----
my @array = <1 2 3 4 5>;
sub kuadrat($x) {
  $x ** 2
}
say map(&kuadrat,@array);
----

.Output
----
(1 4 9 16 25)
----

.Penjelasan
Kita mendefinisikan sebuah subroutine bernama `kuadrat` yang menerima sebuah argumen dan mengalikannnya. +.
Selanjuntnya, kita menggunakan `map`, dan memberikan 2 argumen, subroutine `kuadrat` dan sebuah array. +
Hasilnya adalah sebuah daftar elemen kuadrat dari array.

Perhatikan bahwa ketika memberikan subroutine sebagai argumen, kita perlu menggunakan `&` sebelum nama subroutine.

=== Anonymous functions
Fungsi anonim biasa disebut juga *lambda*. +
Fungsi anonim tidak mempunyai nama.

Mari kita tulis ulang contoh dari `map` dan memakai fungsi anonim
[source,perl6]
----
my @array = <1 2 3 4 5>;
say map(-> $x {$x ** 2},@array);
----
Perhatikan bahwa kita tidak mendeklarasikan subroutine kuadrat.
Kita mendefinisikannya kedalam fungsi anonim sebagai `\-> $x {$x ** 2}`.

Dalam istilah Perl 6, kita memanggilnya sebagai *pointy block*

[source,perl6]
.Sebuah pointy block dapat juga digunakan untuk menempatkan fungsi ke variabel:
----
my $kuadrat = -> $x {
  $x ** 2
}
say $kuadrat(9);
----

=== Chaining
Di Perl 6, methods dapat dirangkai, jadi anda tidak perlu menyerahkan hasil dari satu method ke method lainnya sebagai argumen.

Sebagai ilustrasi: Dalam sebuah array, anda mungkin perlu mengembalikan nilai yang unik, mengurutkannya dari nilai terbesar sampai terkecil.

Solusi dimana methods tidak dirangkai:

[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array = reverse(sort(unique(@array)));
say @final-array;
----
Disini, kita menggunakan `unique` on `@array`, memberikan hasilnya sebagai argumen dari `sort` dan kemudian memberikan hasil ke `reverse`.

Sebaliknya, dengan method yang dirangkai, contoh diatas dapat ditulis sebagai berikut:

[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array = @array.unique.sort.reverse;
say @final-array;
----

Anda dapat melihat bahwa methods yang dirangkai lebih mudah untuk dilihat dimata. 

=== Feed Operator
*feed operator*, biasa disebut _pipe_ dibeberapa pemrograman fungsional, mengilustrasikan lebih lanjut method yang dirangkai.

[source,perl6]
.Forward Feed
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
@array ==> unique()
       ==> sort()
       ==> reverse()
       ==> my @final-array;
say @final-array;
----

.Penjelasan
----
Mulai dengan `@Array`   kemudian mengembalikan daftar elemen yang unik
                        kemudian mengurutkannya
                        kemudian urutannya dibalik
                        kemudian simpah hasilnya di @final-array
----
Alur dari method dieksekusi dari atas kebawah.


[source,perl6]
.Backward Feed
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array-v2 <== reverse()
                   <== sort()
                   <== unique()
                   <== @array;
say @final-array-v2;
----

.Penjelasan
Kebalikan dari forward feed. +
Alur dari method dieksekusi dari bawah keatas.

=== Hyper operator
*hyper operator* `>>.` akan mengeksekusi sebuah method kesemua elemen dan mengembalikan daftar hasilnya.
[source,perl6]
----
my @array = <0 1 2 3 4 5 6 7 8 9 10>;
sub genap($var) { $var %% 2 };

say @array>>.is-prime;
say @array>>.&genap;
----

Kita dapat menggunakan methods bawaan Perl 6 seperti `is-prime` yang mengecek apakah suatu bilangan merupakan bilangan prima atau bukan. +
Kita dapat juga menggunakan subroutine custom. Didalam hal ini `&genap`.

Hal ini sangat praktis mengingat kita tidak perlu menggunakan pengulangan `loop` untuk setiap nilai elemen.

PERINGATAN: Perl 6 memberikan garansi bahwa urutan dari hasil adalah sama dengan daftar yang asli.
            Tetapi tidak ada garansi bahwa Perl 6 akan mengeksekusi methods sesuai daftar urutan atau dalam thread yang sama. Jadi, hati-hati dengan methods yang dapat menimbulkan efek samping, seperti `say` atau `print`.

=== Junctions
A *junction* adalah superpoisi logis dari nilai-nilai.

Contoh dibawah `1|2|3` adalah junction.
[source,perl6]
----
my $var = 2;
if $var == 1|2|3 {
  say "Variabel adalah 1 or 2 or 3"
}
----
Penggunaan junction biasanya memicu *autothreading*;

Proses dilakukan dalam tiap elemen junction dan semua hasilnya digabungkan ke junction baru dan nilainya dikembalikan.

=== Lazy Lists
A *lazy list* adalah sebuah daftar yang dievaluasi secara malas. +
Evaluasi yang malas menunda evaluasi dari sebuah eskpresi sampai diperlukan dan mencegah evaluasi yang berulang dengan menyimpan hasil ditabel pencarian.

Berikut manfaatnya:

* Kinerja bertambah dengan menghindari kalkulasi yang tidak perlu

* Kemampuan untuk membangun struktur data tidak terbatas

* Kemampuan untuk mendefinisikan alur kontrol

Untuk membangun lazy listm kita menggunakan operator infix `...` +
lazy list mempunyai *elemen awal*, *generator* and an *titik akhir*.

[source,perl6]
.Simple lazy list
----
my $lazylist = (1 ... 10);
say $lazylist;
----
Elemen awal adalah 1 dan titik akhir adalah 10. Tidak ada generator yang didefinisikan, jadi defaultnya adalah (+1) +
Dengan kata lain lazy list akan mengembalikan elemen (Jika dipanggil) sebagai berikut (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

[source,perl6]
.lazy list tak terbatas
----
my $lazylist = (1 ... Inf);
say $lazylist;
----
Jika dipanggil maka akan mengembalikan nilai integer antara 1 dan tak terhingga.

[source,perl6]
.Lazy list menggunakan generator yang disimpulkan
----
my $lazylist = (0,2 ... 10);
say $lazylist;
----
Elemen awal adalah 0 dan 2, titik akhir adalah 10.
The initial elements are 0 and 2 and the endpoint is 10.
Tidak ada generator yang didefinisikam tapi menggunakan elemen awal, Perl 6 akan menyimpulkan generator adalah (+2) +
lazy list akan mengembalikan elemen (Jika dipanggil) sebagai berikut (0, 2, 4, 6, 8, 10)

[source,perl6]
.Lazy list menggunakan generator yang didefinisikan
----
my $lazylist = (0, { $_ + 3 } ... 12);
say $lazylist;
----
Dicontoh ini, kita mendefinisikan secara eksplisit sebuah generator dalan `{ }` +
lazy list akan mengembalikan elemen (Jika dipanggil) sebagai berikut (0, 3, 6, 9, 12)

[PERINGATAN]
====
Ketika menggunakan generator secara eksplisit, titik akhir harus nilai yang dapat digenerate oleh generator. +
Jika titik akhir contoh diatas diubah menjadi 10, maka program tidak akan berhenti.

Alternatifnya anda dapat mengganti `0 ... 10` dengan `0 ...^ * > 10` +
Dapat dibaca: Dari 0 sampai nilai pertama yang lebih dari 10 (tidak termasuk)

[source,perl6]
.Dicontoh ini generator tidak akan berhenti
----
my $lazylist = (0, { $_ + 3 } ... 10);
say $lazylist;
----

[source,perl6]
.Dicontoh ini generator bisa berhenti
----
my $lazylist = (0, { $_ + 3 } ...^ * > 10);
say $lazylist;
----
====

=== Closures
Semua kode objek di Perl 6 adalah closures, artinya objek dapat direferensikan ke variabel dari lingkup luarnya.

[source,perl6]
----
sub selamat-pagi {
    my $nama = "Wiro Sableng";
    sub salam {
      say "Selamat pagi $nama";
    };
    return &salam;
}
my $ucapan = selamat-pagi;
$ucapan();
----

Jika anda menjalankan kode diatas, maka akan ada output `Selamat pagi Wiro Sableng` diterminal. +
Yang menarik dari contoh tersebut adalah subroutine `salam` yang ada didalam subroutine `selamat-pagi` dikembalikan nilainya sebelum dieksekusi.

`$ucapan` telah menjadi sebuah *closure*.

*closure* adalah objek spesial yang mengkombinasi 2 hal:

* Sebuah subroutine

* Environment dimana subroutine dibuat.

Environment terdiri dari variabel lokal yang didalam lingkupnya, pada saat itulah clouser terbuat.
Dicontoh diatas, `$ucapan` adalah closure yang menggabungkan subroutine `salam` dan string `Wiro Sableng`.

Mari kita lihat lebih lanjut kecontoh yang lebih menarik.
[source,perl6]
----
sub selamat($periode) {
  return sub ($nama) {
    return "Selamat $periode $nama"
  }
}
my $pagi  = selamat("Pagi");
my $malam = selamat("Malam");

say $pagi("John");
say $malam("Jane");
----
Dicontoh ini, kita mendefinisikan sebuah subroutine `selamat($periode)` yang menerima satu argumen `$periode`
dan megembalikan subroutine baru. Subroutine tersebut menerima satu argumen `$nama` dan mengembalikan gabungan argumen.

Dicontoh ini kita menggunakan subroutine `selamat` untuk membuat 2 subroutine baru, yang pertama mengeluarkan output `Selamat Pagi` 
dan satu lagi `Selamat Malam`.

`$pagi` dan `$malam` keduanya adalah closures. Mereka sama-sama memakai subroutine yang sama, tetapi berbeda environment. + 
Pada environment `$pagi`, `$periode` nya `Pagi` sedangkan `$malam`, `$periode` nya `Malam`.

== Classes & Objects
Dichapter ini kita akan membahas pemrograman berbasis objek pada Perl 6.

=== Pengenalan

Pemrograman berbasis objek adalah paradigma yang secara luas diadopsi dijaman sekarang. +
Sebuah objek adalah set dari variabel dan subroutine yang digabungkan bersama-sama. +
Variabel disebut *attributes* dan subroutine disebut *methods*. +
Atribut mendefinisikan *state* dan methods mendefinisikan *behavior* dari sebuah objek.

Sebuah *class* adalah template untuk membuat objek.+

Untuk dapat lebih memahami relasinya, lihat contoh dibawah:

|===

| Ada 4 orang didalam suatu ruangan | *objek* => 4 orang

| ke 4 orang ini adalah manusia | *class* => Manusia

| Masing-masing mempunyai nama, umur, jenis kelamin, kebangsaan yang berbeda | *attributes* => nama, umur, jenis kelamin, kebangsaan

|===

Dalam istilah pemprograman berbasis objek, objek adalah *instances* dari sebuah kelas.

Perhatikan skrip dibawah:
[source,perl6]
----
class Manusia {
  has $.nama;
  has $.umur;
  has $.jenis_kelamin;
  has $.kebangsaan;
}

my $john = Manusia.new(nama => 'John', umur => 23, jenis_kelamin => 'M', kebangsaan => 'American');
say $john;
----
Kata kunci `class` digunakan untuk mendefinisikan sebuah class. +
Kata kunci `has` digunakan untuk mendefiniskan atribut dari sebuah class. +
Method `.new()` disebut *constructor*. method ini membuat objek sebagai instansi dari class yang dipanggil.

Pada contoh diatas, variabel `$john` menampung referensi kepada instansi baru "Manusia" yang didefinisikan melalui `Manusia.new()`. + 
Argumen-argumen yang dideklarasikan pada method `.new()` digunakan untuk memberikan nilai kepada atribut-atribut class tersebut.

Sebuah kelas dapat diberikan ruang lingkup lexical menggunakan kata kunci `my`:
[source,perl6]
----
my class Manusia {

}
----

=== Enkapsulasi
Enkapsulasi adalah konsep basis objek yang membundel suatu set data dan methods bersama-sama. +
Data (atribut) didalam suatu objek bersifat *private*, dengan kata lain, hanya bisa diakses didalam lingkup objek tersebut saja. +
Untuk mengakses atribut dari luar objek, kita menggunakan methods yang disebut *accessors*.

Kedua skrip dibawah memhasilkan output yang sama.

.Akses langsung ke variabel:
[source,perl6]
----
my $var = 7;
say $var;
----

.Enkapsulasi:
[source,perl6]
----
my $var = 7;
sub sayvar {
  $var;
}
say sayvar;
----
Method `sayvar` adalah sebuah accessor. Ia memungkinkan akses nilai dari suatu variabel tanpa akses langsung.

Enkapsulasi difasilitasi dengan penggunaan *twigils*. +
Twigils adalah sekunder dari _sigils_. Posisinya berada diantara sigil dan nama atribut. +
Kedua twigils ini dapat digunakan dalam class:

* `!` digunakan untuk secara eksplisit mendeklarasikan sebuah atribut adalah private (hanya dapat diakses didalam lingkup objek).
* `.` digunakan untuk secara otomatis menghasilkan sebuah accessor untuk atribut maka atribut tersebut dapat diakses diluar lingkup objek.

Defaultnya, semua atribut adalah private tetapi disarankan untuk selalu menggunakan twigil `!`.

Maka kita harusnya menulis ulang class diatas sebagai berikut:
[source,perl6]
----
class Manusia {
  has $!nama;
  has $!umur;
  has $!jenis_kelamin;
  has $!kebangsaan;
}

my $john = Manusia.new(nama => 'John', umur => 23, jenis_kelamin => 'M', kebangsaan => 'American');
say $john;
----
Tambahkan statement berikut dalam skrip diatas: `say $john.umur;` +
Program akan mengembalikan error: `Method 'umur' not found for invocant of class 'Human'`
Karena `$!umur` bersifat private dan hanya bisa digunakan didalam ruang lingkup objek.

Sekarang coba ganti `has $!umur` menjadi `has $.umur` dan perhatikan hasil dari `say $john.umur;`

=== Named vs. Positional Parameters
Dalam Perl 6, semua class menurunkan default konstruktor `.new()`. +
Konstruktor tersebut dapat digunakan untuk membuat objek dengan memberikan argumen. +
Defaultnya, argumen pada konstruktor hanya dapat diberikan dengan *named arguments*. +
Dalam contoh diatas, perhatikan argumen yang diberikan ke `.new()` didefinisikan dengan penamaan:

* nama => 'John'

* umur => 23


Bagaimana jika kita tidak ingin memberikan nama dari tiap atribut setiap kali kita ingin mebuat objek? +
Maka kita harus membuat konstruktor lain yang menerima *positional arguments*.

[source,perl6]
----
class Manusia {
  has $.nama;
  has $.umur;
  has $.jenis_kelamin;
  has $.kebangsaan;
  # konstruktor baru yang mengganti defaultnya(named parameter).
  method new ($nama,$umur,$jenis_kelamin,$kebangsaan) {
    self.bless(:$nama,:$umur,:$jenis_kelamin,:$kebangsaan);
  }
}

my $john = Manusia.new('John',23,'M','American');
say $john;
----

=== Methods

==== Pengenalan
Methods adalah subroutine dari sebuah objek. +
Seperti layaknya subroutine, tujuannya adalah mengemas fungsi, dapat menerima argumen, mempunyai *signature* dan dapat didefinisikan sebagai *multi*.

Methods didefinisikan dengan mengunakan kata kunci `method`. +
Dalam keadaan normal, methods diperlukan untuk melancarkan suatu aksi kepada atribut objek.
This enforces the concept of encapsulation. Object attributes can only be manipulated from within the object using methods.
The outside world can only interact with the object methods, and has no direct access to its attributes.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  has $.sex;
  has $.nationality;
  has $.eligible;
  method assess-eligibility {
      if self.age < 21 {
        $!eligible = 'No'
      } else {
        $!eligible = 'Yes'
      }
  }

}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
$john.assess-eligibility;
say $john.eligible;
----

Once methods are defined within a class, they can be called on an object using the _dot notation_: +
_object_ *.* _method_ or as in the above example: `$john.assess-eligibility`

Within the definition of a method, if we need to reference the object itself to call another method we use the `self` keyword. +

Within the definition of a method, if we need to reference an attribute we use `!` even if it was defined with `.` +
The rationale being that what the `.` twigil does is declare an attribute with `!` and automate the creation of an accessor.

In the above example, `if self.age < 21` and `if $!age < 21` would have the same effect, although they are technically different:

* `self.age` calls the `.age` method (accessor) +
Can be written alternatively as `$.age`
* `$!age` is a direct call to the variable

==== Private methods
Normal methods can be called on objects from outside the class.

*Private methods* are methods that can only be called from within the class. +
A possible use case would be a method that calls another one for specific action.
The method that interfaces with the outside world is public while the one referenced should stay private.
We do not want users to call it directly, so we declare it as private.

The declaration of a private method requires the use of the `!` twigil before its name. +
Private methods are called with `!` instead of `.`

[source,perl6]
----
method !iamprivate {
  # code goes in here
}

method iampublic {
  self!iamprivate;
  # do additional things
}
----

=== Class Attributes

*Class attributes* are attributes that belong to the class itself and not to its objects. +
They can be initialized during definition. +
Class attributes are declared using `my` instead of `has`. +
They are called on the class itself instead of its objects.

[source,perl6]
----
class Human {
  has $.name;
  my $.counter = 0;
  method new($name) {
    Human.counter++;
    self.bless(:$name);
  }
}
my $a = Human.new('a');
my $b = Human.new('b');

say Human.counter;
----

=== Access Type
Until now, all the examples that we've seen have used accessors to *get* information from the objects' attributes.

What if we need to modify the value of an attribute? +
We need to label it as _read/write_ using the keywords `is rw`
[source,perl6]
----
class Human {
  has $.name;
  has $.age is rw;
}
my $john = Human.new(name => 'John', age => 21);
say $john.age;

$john.age = 23;
say $john.age;
----
By default, all attributes are declared as _read only_ but you can explicitly do it using `is readonly`

=== Inheritance
==== Introduction
*Inheritance* is another concept of object oriented programming.

When defining classes, soon enough we will realize that some attributes/methods are common to many classes. +
Should we duplicate code? +
NO! We should use *inheritance*

Let's consider we want to define two classes, a class for Human beings and a class for Employees. +
Human beings have 2 attributes: name and age. +
Employees have 4 attributes: name, age, company and salary

One would be tempted to define the classes as:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee {
  has $.name;
  has $.age;
  has $.company;
  has $.salary;
}
----
While technically correct, the above piece of code is considered conceptually poor.

A better way to write this would be:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee is Human {
  has $.company;
  has $.salary;
}
----
The `is` keyword defines inheritance. +
In object oriented parlance, we say Employee is a *child* of Human and that Human is a *parent* of Employee.

All child classes inherit the attributes and methods of the parent class, so there is no need to redefine them.

==== Overriding
Classes inherit all attributes and methods from their parent classes. +
There are cases where we need the method in the child class to behave differently than the one inherited. +
To achieve this, we redefine the method in the child class. +
This concept is called *overriding*.

In the below example, the method `introduce-yourself` is inherited by the Employee class.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi I am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
}

my $john = Human.new(name =>'John', age => 23,);
my $jane = Employee.new(name =>'Jane', age => 25, company => 'Acme', salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----
Overriding works like this:

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi I am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
  method introduce-yourself {
    say 'Hi I am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }

}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----

Depending of which class the object is, the right method will be called.

==== Submethods
*Submethods* are a type of method that are not inherited by child classes. +
They are only accessible from the class they were declared in. +
They are defined using the `submethod` keyword.

=== Multiple Inheritance
Multiple inheritance is allowed in Perl 6. A class can inherit from multiple other classes.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
----

.Explanation
The `combo-chart` class should be able to hold two series, one for the actual values plotted on bars,
and another for forecast values plotted on a line. +
This is why we defined it as a child of `line-chart` and `bar-chart`. +
You should have noticed that calling the method `plot` on the `combo-chart` didn't yield the required result.
Only one series was plotted. +
Why did this happen? +
`combo-chart` inherits from `line-chart` and `bar-chart`, and both of them have a method called `plot`.
When we call that method on `combo-chart` Perl 6 internals will try to resolve the conflict by calling one of the inherited methods.

.Correction
In order to behave correctly, we should have overridden the method `plot` in the `combo-chart`.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
[9 8 10 7 6 9]
----

=== Roles
*Roles* are similar to classes in that they are a collection of attributes and methods.

Roles are declared with the keyword `role`. Classes that wish to implement a role, do so using the `does` keyword.

.Let's rewrite the multiple inheritance example using roles:
[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

Run the above script and you will see that results are the same.

By now you're asking yourself: If roles behave like classes, what's their use? +
To answer your question, modify the first script used to showcase multiple inheritance,
the one where we _forgot_ to override the `plot` method.

[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
===SORRY!===
Method 'plot' must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)
----

.Explanation
If multiple roles are applied to the same class and a conflict exists, a compile-time error will be thrown. +
This is a much safer approach than multiple inheritance, where conflicts are not considered errors and are simply resolved at runtime.

Roles will warn you that there's a conflict.

=== Introspection
*Introspection* is the process of getting information about an object, like its type, attributes or methods.

[source,perl6]
----
class Human {
  has Str $.name;
  has Int $.age;
  method introduce-yourself {
    say 'Hi I am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has Str $.company;
  has Int $.salary;
  method introduce-yourself {
    say 'Hi I am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }
}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

say $john.WHAT;
say $jane.WHAT;
say $john.^attributes;
say $jane.^attributes;
say $john.^methods;
say $jane.^methods;
say $jane.^parents;
if $jane ~~ Human {say 'Jane is a Human'};
----
Introspection is facilitated by:

* `.WHAT` -- returns the class from which the object was created

* `.^attributes` -- returns all the attributes of the object

* `.^methods` -- returns all the methods that can be called on the object

* `.^parents` -- returns the parent classes of the object

* `~~` is called the smart-match operator.
It evaluates to _True_ if the object is created from the class it is being compared against or any of its inheritances.

[NOTE]
--
For more info on Object Oriented Programming in Perl 6, see:

* https://docs.perl6.org/language/classtut
* https://docs.perl6.org/language/objects
--
== Exception Handling

=== Catching Exceptions
*Exceptions* are a special behavior that happens at runtime when something goes wrong. +
We say that exceptions are _thrown_.

Consider the below script that runs correctly:

[source,perl6]
----
my Str $name;
$name = "Joanna";
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Hello Joanna
How are you doing today?
----

Now consider this script that throws an exception:

[source,perl6]
----
my Str $name;
$name = 123;
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Type check failed in assignment to $name; expected Str but got Int
   in block <unit> at exceptions.pl6:2
----

Notice that whenever an error occurs (in this case, assigning a number to a string variable) the program will stop and other lines of code will not be evaluated.

*Exception handling* is the process of _catching_ an exception that has been _thrown_ in order for the script to continue working.

[source,perl6]
----
my Str $name;
try {
  $name = 123;
  say "Hello " ~ $name;
  CATCH {
    default {
      say "Can you tell us your name again, we couldn't find it in the register.";
    }
  }
}
say "How are you doing today?";
----

.`Output`
----
Can you tell us your name again, we couldn't find it in the register.
How are you doing today?
----

Exception handling is done by using a `try-catch` block.

[source,perl6]
----
try {
  # code goes in here
  # if anything goes wrong, the script will enter the below CATCH block
  # if nothing goes wrong, the CATCH block will be ignored
  CATCH {
    default {
      # the code in here will be evaluated only if an exception has been thrown
    }
  }
}
----

The `CATCH` block can be defined the same way a `given` block is defined.
This means we can _catch_ and handle differently many types of exceptions.

[source,perl6]
----
try {
  # code goes in here
  # if anything goes wrong, the script will enter the below CATCH block
  # if nothing goes wrong, the CATCH block will be ignored
  CATCH {
    when X::AdHoc   { # do something if exception of type X::AdHoc is thrown }
    when X::IO      { # do something if exception of type X::IO is thrown }
    when X::OS      { # do something if exception of type X::OS is thrown }
    default         { # do something if exception is thrown and doesn't belong to the above types }
  }
}
----

=== Throwing Exceptions
Perl 6 also allows you to explicitly throw exceptions. +
Two types of exceptions can be thrown:

* ad-hoc exceptions

* typed exceptions

[source,perl6]
.ad-hoc
----
my Int $age = 21;
die "Error !";
----

[source,perl6]
.typed
----
my Int $age = 21;
X::AdHoc.new(payload => 'Error !').throw;
----

Ad-hoc exceptions are thrown using the `die` subroutine, followed by the exception message.

Typed exceptions are objects, hence the use of the `.new()` constructor in the above example. +
All typed exceptions descend from class `X` , below are a few examples: +
`X::AdHoc` is the simplest exception type +
`X::IO` is related to IO errors +
`X::OS` is related to OS errors +
`X::Str::Numeric` related to trying to coerce a string to a number

NOTE: For a complete list of exception types and their associated methods, go to https://docs.perl6.org/type-exceptions.html


== Regular Expressions
A regular expression, or _regex_, is a sequence of characters that is used for pattern matching. +
Think of it as a pattern.

[source,perl6]
----
if 'enlightenment' ~~ m/ light / {
    say "enlightenment contains the word light";
}
----

In this example, the smart match operator `~~` is used to check if a string (enlightenment) contains the word (light). +
"Enlightenment" is matched against the regex `m/ light /`

=== Regex definition

A regular expression can be defined like this:

* `/light/`

* `m/light/`

* `rx/light/`

Unless specified explicitly, white space is ignored; `m/light/` and `m/ light /` are the same.

=== Matching characters
Alphanumeric characters and the underscore `_` are written as is. +
All other characters have to be escaped using a backslash or surrounded by quotes.

[source,perl6]
.Backslash
----
if 'Temperature: 13' ~~ m/ \: / {
    say "The string provided contains a colon :";
}
----

[source,perl6]
.Single quotes
----
if 'Age = 13' ~~ m/ '=' / {
    say "The string provided contains an equal character = ";
}
----

[source,perl6]
.Double quotes
----
if 'name@company.com' ~~ m/ "@" / {
    say "This is a valid email address because it contains an @ character";
}
----

=== Matching categories of characters
Characters can be classified into categories and we can match against them. +
We can also match against the inverse of that category (everything except it):

|===

| *Category* | *Regex* | *Inverse* | *Regex*

| Word character (letter, digit or underscore) | \w | Any character except a word character | \W

| Digit | \d | Any character except a digit | \D

| Whitespace | \s | Any character except a whitespace | \S

| Horizontal whitespace | \h | Any character except a horizontal whitespace | \H

| Vertical whitespace | \v | Any character except a vertical whitespace | \V

| Tab | \t | Any character except a Tab | \T

| New line | \n | Any character except a new line | \N

|===

[source,perl6]
----
if "John123" ~~ / \d / {
  say "This is not a valid name, numbers are not allowed";
} else {
  say "This is a valid name"
}
if "John-Doe" ~~ / \s / {
  say "This string contains whitespace";
} else {
  say "This string doesn't contain whitespace"
}
----

=== Unicode properties
Matching against categories of characters, as seen in the preceding section, is convenient. +
That being said, a more systematic approach would be to use Unicode properties. +
This allows you to match against categories of characters inside and outside of +
the ASCII standard. +
Unicode properties are enclosed in `<: >`

[source,perl6]
----
if "Devanagari Numbers १२३" ~~ / <:N> / {
  say "Contains a number";
} else {
  say "Doesn't contain a number"
}
if "Привет, Иван." ~~ / <:Lu> / {
  say "Contains an uppercase letter";
} else {
  say "Doesn't contain an upper case letter"
}
if "John-Doe" ~~ / <:Pd> / {
  say "Contains a dash";
} else {
  say "Doesn't contain a dash"
}
----

=== Wildcards
Wildcards can also be used in a regex.

The dot `.` means any single character.

[source,perl6]
----
if 'abc' ~~ m/ a.c / {
    say "Match";
}
if 'a2c' ~~ m/ a.c / {
    say "Match";
}
if 'ac' ~~ m/ a.c / {
    say "Match";
} else {
    say "No Match";
}
----

=== Quantifiers
Quantifiers come after a character and are used to specify how many times we are expecting it.

The question mark `?` means zero or one time.

[source,perl6]
----
if 'ac' ~~ m/ a?c / {
    say "Match";
} else {
    say "No Match";
}
if 'c' ~~ m/ a?c / {
    say "Match";
} else {
    say "No Match";
}
----

The star `*` means zero or multiple times.

[source,perl6]
----
if 'az' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaz' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
if 'z' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
----

The `+` means at least one time.

[source,perl6]
----
if 'az' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaz' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
if 'z' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
----

=== Match Results
Whenever the process of matching a string against a regex is successful,
the match result is stored in a special variable `$/`

[source,perl6]
.Script
----
if 'Rakudo is a Perl 6 compiler' ~~ m/:s Perl 6/ {
    say "The match is: " ~ $/;
    say "The string before the match is: " ~ $/.prematch;
    say "The string after the match is: " ~ $/.postmatch;
    say "The matching string starts at position: " ~ $/.from;
    say "The matching string ends at position: " ~ $/.to;
}
----

.Output
----
The match is: Perl 6
The string before the match is: Rakudo is a
The string after the match is: compiler
The matching string starts at position: 12
The matching string ends at position: 18
----

.Explanation
`$/` returns a _Match Object_ (the string that matches the regex) +
The following methods can be called on the _Match Object_: +
`.prematch` returns the string preceding the match. +
`.postmatch` returns the string following the match. +
`.from` returns the starting position of the match. +
`.to` returns the ending position of the match. +

TIP: By default, whitespace in a regex definition is ignored. +
If we want to match against a regex containing whitespace, we have to do so explicitly. +
The `:s` in the regex `m/:s Perl 6/` forces whitespace to be considered. +
Alternatively, we could have written the regex as `m/ Perl\s6 /` and used `\s` which represents a whitespace. +
If a regex contains more than a single whitespace, using `:s` is a better option than using `\s` for each and every whitespace.

=== Example
Let's check if an email is valid or not. +
For the sake of this example we will assume that a valid email address has this format: +
first name [dot] last name [at] company [dot] (com/org/net)

WARNING: The regex used in this example for email validation is not very accurate. +
Its sole purpose is to demonstrate regex functionality in Perl 6. +
Do not use it as-is in production.

[source,perl6]
.Script
----
my $email = 'john.doe@perl6.org';
my $regex = / <:L>+\.<:L>+\@<:L+:N>+\.<:L>+ /;

if $email ~~ $regex {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

.Output
`john.doe@perl6.org is a valid email`

.Explanation
`<:L>` matches a single letter +
`<:L>+` matches one or more letters +
`\.` matches a single [dot] character +
`\@` matches a single [at] character +
`<:L+:N>` matches a letter or a single number +
`<:L+:N>+` matches one or more letters or numbers +

The regex can be decomposed as following:

* *first name* `<:L>+`

* *[dot]* `\.`

* *last name* `<:L>+`

* *[at]* `\@`

* *company name* `<:L+:N>+`

* *[dot]* `\.`

* *com/org/net* `<:L>+`

[source,perl6]
.Alternatively, a regex can be broken down into multiple named regexes
----
my $email = 'john.doe@perl6.org';
my regex many-letters { <:L>+ };
my regex dot { \. };
my regex at { \@ };
my regex many-letters-numbers { <:L+:N>+ };

if $email ~~ / <many-letters> <dot> <many-letters> <at> <many-letters-numbers> <dot> <many-letters> / {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

A named regex is defined using the following syntax: `my regex regex-name { regex definition }` +
A named regex can be called using the following syntax: `<regex-name>`

NOTE: For more info on regexes, see https://docs.perl6.org/language/regexes

== Perl 6 Modules
Perl 6 is a general purpose programming language. It can be used to tackle a multitude of tasks including:
text manipulation, graphics, web, databases, network protocols etc.

Reusability is a very important concept whereby programmers don't have to reinvent the wheel each time they want to do a new task.

Perl 6 allows the creation and redistribution of *modules*. Each module is a packaged set of functionality that can be reused once installed.

_Zef_ is a module management tool that comes with Rakudo Star.

To install a specific module, type the below command in your terminal:

`zef install "module name"`

NOTE: The Perl 6 modules directory can be found on: https://modules.perl6.org/

=== Using Modules
MD5 is a cryptographic hash function that produces a 128-bit hash value. +
MD5 has a variety of applications, including the encryption of stored passwords in a database.
When a new user registers, their credentials are not stored as plain text but rather _hashed_.
The rationale behind this is that if the DB gets compromised, the attacker will not be able to know what the passwords are.

Luckily, you don't need to implement the MD5 algorithm yourself; there's a Perl 6 module already implemented.

Let's install it: +
`zef install Digest::MD5`

Now, run the below script:
[source,perl6]
----
use Digest::MD5;
my $password = "password123";
my $hashed-password = Digest::MD5.new.md5_hex($password);

say $hashed-password;
----
In order to run the `md5_hex()` function that creates hashes, we need to load the required module. +
The `use` keyword loads the module for use in the script.

WARNING: In practice MD5 hashing alone is not sufficient, because it is prone to dictionary attacks. +
It should be combined with a salt link:https://en.wikipedia.org/wiki/Salt_(cryptography)[https://en.wikipedia.org/wiki/Salt_(cryptography)].

== Unicode

Unicode is a standard for encoding and representing text for most writing systems in the world. +
UTF-8 is a character encoding capable of encoding all possible characters, or code points, in Unicode.

Characters are defined by a: +
*Grapheme*: Visual representation. +
*Code point*: A number assigned to the character.

=== Using Unicode

.Let's look at how we can output characters using Unicode
[source,perl6]
----
say "a";
say "\x0061";
say "\c[LATIN SMALL LETTER A]";
----
The above 3 lines showcase different ways of building a character:

. Writing the character directly (grapheme)

. Using `\x` and the code point

. Using `\c` and the code point name

.Now lets output a smiley
[source,perl6]
----
say "☺";
say "\x263a";
say "\c[WHITE SMILING FACE]";
----

.Another example combining two code points
[source,perl6]
----
say "á";
say "\x00e1";
say "\x0061\x0301";
say "\c[LATIN SMALL LETTER A WITH ACUTE]";
----

The letter `á` can be written:

* using its unique code point `\x00e1`

* or as a combination of the code points of `a` and acute `\x0061\x0301`

.Some of the methods that can be used:
[source,perl6]
----
say "á".NFC;
say "á".NFD;
say "á".uniname;
----

.`Output`
----
NFC:0x<00e1>
NFD:0x<0061 0301>
LATIN SMALL LETTER A WITH ACUTE
----

`NFC` returns the unique code point. +
`NFD` decomposes the character and return the code point of each part. +
`uniname` returns the code point name.

.Unicode letters can be used as identifiers:
[source,perl6]
----
my $Δ = 1;
$Δ++;
say $Δ;
----

.Unicode can be used to do math:
[source,perl6]
----
my $var = 2 + ⅒;
say $var;
----

== Parallelism, Concurrency and Asynchrony

=== Parallelism
Under normal circumstances, all tasks in a program run sequentially. +
This might not be a problem, unless what you're trying to do takes a lot of time.

Thankfully, Perl 6 has features that will enable you to run things in parallel. +
At this stage, it is important to note that parallelism can mean one of two things:

* *Task Parallelism*: Two (or more) independent expressions running in parallel.

* *Data Parallelism*: A single expression iterating over a list of elements in parallel.

Let's begin with the latter.

==== Data Parallelism
[source,perl6]
----
my @array = (0..50000);                     # Array population
my @result = @array.map({ is-prime $_ });   # call is-prime for each array element
say now - INIT now;                         # Output the time it took for the script to complete
----

.Considering the above example:
We are only doing one operation `@array.map({ is-prime $_ })` +
The `is-prime` subroutine is being called for each array element sequentially: +
`is-prime @array[0]` then `is-prime @array[1]` then `is-prime @array[2]` etc.

.Fortunately we can call `is-prime` on multiple array elements at the same time:
[source,perl6]
----
my @array = (0..50000);                         # Array population
my @result = @array.race.map({ is-prime $_ });  # call is-prime for each array element
say now - INIT now;                             # Output the time it took to complete
----

Notice the use of `race` in the expression.
This method will enable parallel iteration of the array elements.

After running both examples (with and without `race`), compare the time it took for both scripts to complete.

[TIP]
====
`race` will not preserve the order of elements. If you wish to do, so use `hyper` instead.

[source,perl6]
.race
----
my @array = (1..1000);
my @result = @array.race.map( {$_ + 1} );
.say for @result;
----

[source,perl6]
.hyper
----
my @array = (1..1000);
my @result = @array.hyper.map( {$_ + 1} );
.say for @result;
----

If you run both examples, you should notice that one is sorted and the other is not.

====

==== Task Parallelism

[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my @result1 = @array1.map( {is-prime($_ + 1)} );
my @result2 = @array2.map( {is-prime($_ - 1)} );

say @result1 eqv @result2;

say now - INIT now;
----

.Considering the above example:

. We defined 2 arrays

. applied a different operation for each array and stored the results

. and checked if both results are the same

The script waits for `@array1.map( {is-prime($_ + 1)} )` to finish +
and then evaluates `@array2.map( {is-prime($_ - 1)} )`

Both operations applied to each array do not depend on each other.

.Why not do both in parallel?
[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my $promise1 = start @array1.map( {is-prime($_ + 1)} ).eager;
my $promise2 = start @array2.map( {is-prime($_ - 1)} ).eager;

my @result1 = await $promise1;
my @result2 = await $promise2;

say @result1 eqv @result2;

say now - INIT now;
----

.Explanation
The `start` subroutine evaluates the code and returns *an object of type promise* or shortly *a promise*. +
If the code is evaluated correctly, the _promise_ will be *kept*. +
If the code throws an exception, the _promise_ will be *broken*.

The `await` subroutine waits for a *promise*. +
If it's *kept* it will get the returned values. +
If it's *broken* it will get the exception thrown.

Check the time it took each script to complete.

WARNING: Parallelism always adds a threading overhead. If that overhead is not offset by gains in computational speed, the script will seem slower. +
This is why, using `race`, `hyper`, `start` and `await` for fairly simple scripts can actually slow them down.

=== Concurrency and Asynchrony
NOTE: For more info on Concurrency and Asynchronous Programming, see https://docs.perl6.org/language/concurrency

== Native Calling Interface

Perl 6 gives us the ability to use C libraries, using the Native Calling Interface.

`NativeCall` is a standard module that ships with Perl 6 and offers a set of functionality to ease the job
of interfacing Perl 6 and C.

=== Calling a function

Consider the below C code that defines a function called `hellofromc`.
This function prints on the terminal `Hello from C`. It doesn't accept any argument nor return any value.

[source,c]
.ncitest.c
----
#include <stdio.h>

void hellofromc () {
  printf("Hello from C\n");
}
----

Depending on your OS run the following commands to compile the above C code into a library.

.On Linux:
----
gcc -c -fpic ncitest.c
gcc -shared -o libncitest.so ncitest.o
----

.On Windows:
----
gcc -c ncitest.c
gcc -shared -o ncitest.dll ncitest.o
----

Within the same directory where you compiled your C library, create a new Perl 6
file that contains the below code and run it.

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub hellofromc() is native(LIBPATH) { * }

hellofromc();
----

.Explanation:
First of all we declared that we will be using the `NativeCall` module. +
Then we created a constant `LIBPATH` that holds the path to the C library. +
Notice that `$*CWD` returns the current working directory. +
Then we created a new Perl 6 subroutine called `hellofromc()` that should act as a
wrapper to its counterpart C function having the same name and residing in the C
library found in `LIBPATH`. +
All of this was done by using the `is native` trait. +
Finally we called our Perl 6 subroutine.

In essence, it all boils down to declaring a subroutine with the trait `is native` and the name of the C library.

=== Renaming a function

In the above part, we saw how we can call a very simple C function by wrapping
it with a Perl 6 subroutine having the same name, using the `is native` trait.

In some cases, we would want to change the name of the Perl 6 subroutine. +
To do so, we use the `is symbol` trait.

Lets modify the above Perl 6 script and rename the Perl 6 subroutine `hello`
instead of `hellofromc`

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub hello() is native(LIBPATH) is symbol('hellofromc') { * }

hello();
----

.Explanation:
In case the Perl 6 subroutine has a different name than its C counterpart, we
should use the `is symbol` trait with the name of the original C function.

=== Passing Arguments

Compile the following modified C library and run the Perl 6 script found below again. +
Notice how we modified both C and Perl 6 code to accept a string (`char*` in C and `Str` in Perl 6)

[source,c]
.ncitest.c
----
#include <stdio.h>

void hellofromc (char* name) {
  printf("Hello, %s! This is C!\n", name);
}
----

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub hello(Str) is native(LIBPATH) is symbol('hellofromc') { * }

hello('Jane');
----

=== Returning values

Lets repeat the process one more time and create a simple calculator that takes
2 integers and add them. +
Compile the C library and run the Perl 6 script.

[source,c]
.ncitest.c
----
int add (int a, int b) {
  return (a + b);
}
----

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub add(int32,int32) returns int32 is native(LIBPATH) { * }

say add(2,3);
----

Notice how both C and Perl 6 functions accept two integers and return one
(`int` in C and `int32` in Perl 6)

=== Types

You might have asked yourself why did we use `int32` instead of `Int` in the latest Perl 6 script. +
Some Perl 6 types like `Int`, `Rat` etc. can't be used as is to pass and receive values from a C function. +
One must use in Perl 6 the same types as the ones in C.

Luckily Perl 6 provides many types that map to their respective C counterpart.

[cols="^.^,^.^",options="header"]
|===

| C Type | Perl 6 Type

| `char` .2+| `int8`

| `int8_t`

| `short` .2+| `int16`

| `int16_t`

| `int` .2+| `int32`

| `int32_t`

| `int64_t` | `int64`

| `unsigned char` .2+| `uint8`

| `uint8_t`

| `unsigned short` .2+| `uint16`

| `uint16_t`

| `unsigned int` .2+| `uint32`

| `uint32_t`

| `uint64_t` | `uint64`

| `long` | `long`

| `long long` | `longlong`

| `float` | `num32`

| `double` | `num64`

| `size_t` | `size_t`

| `bool` | `bool`

| `char*` (String) | `Str`

| Arrays: For example `int*` (Array of int) and `double*` (Array of double) | `CArray`: For example `CArray[int32]` and `CArray[num64]`

|===

NOTE: For more info on the Native Calling Interface, see https://docs.perl6.org/language/nativecall

== The Community

* link:irc://irc.freenode.net/#perl6[#perl6] IRC channel. Much discussion happens on IRC. This should be your go to place for any enquiry: https://perl6.org/community/irc

* link:https://p6weekly.wordpress.com[p6weekly] a weekly overview of changes in and around Perl 6.

* link:http://pl6anet.org[pl6anet] blog aggregator. Stay tuned by reading blog posts that focus on Perl 6.

* link:https://www.reddit.com/r/perl6/[/r/perl6] Subscribe to the Perl 6 subreddit.
