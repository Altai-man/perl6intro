= Perl 6 Introduzione
:descrizione: Introduzione generale a Perl 6
:Author: Naoum Hankache; MarsMarsico <marsmarsico@tiscali.it>
:keywords: perl6, perl 6, introduzione, perl6intro, perl 6 introduzione, perl 6 tutorial, perl 6 intro
:Revision: 1.0
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:doctype: book
:lang: it


Scopo di questo documento è dare una veloce panoramica del linguaggio di 
programmazione Perl 6. Per i neofiti di Perl 6, questo dovrebbe mettere in grado di partire.

Alcune sezioni di questo documento si riferiscono ad altre parti della http://docs.perl6.org[Perl 6 documentation]
(più completa ed accurata); consultale in caso di necessità di maggiori informazioni. 

In questo documento, troverai esempi sulle materie più in voga.
Per comprenderli meglio, prenditi il tempo di riprodurre tutti gli esempi.

.Licenza
Questo lavoro è licenziato sotto Creative Commons Attribution-ShareAlike 4.0 International License.
Per vederne una copia, vista

* https://creativecommons.org/licenses/by-sa/4.0/.

.Contributi
Se vuoi contribuire a questo documento, riferisciti a:

* https://github.com/hankache/perl6intro

.Feedback
tutti i feedback sono benvenuti:
naoum@hankache.com
marsmarsico@tiscali.it

Se questo lavoro ti piace, clicca la _Star_ nel repository che trovi qui:
link:https://github.com/hankache/perl6intro[Github].

.Versioni disponibili
* Bulgaro: http://bg.perl6intro.com
* Cinese: http://zh.perl6intro.com
* Olandese: http://nl.perl6intro.com
* Francese: http://fr.perl6intro.com
* Tedesco: http://de.perl6intro.com
* Giapponese: http://ja.perl6intro.com
* Portoghese: http://pt.perl6intro.com
* Spagnolo: http://es.perl6intro.com

:sectnums:
== Introduzione
=== Cos'è Perl 6
Perl 6 è un linguaggio gradualmente tipizzato, di alto livello, general-purpose.
Perl 6 è multiparadigmatico. Supporta sia programmazione procedurale
che orientatata agli oggetti che funzionale.

.Il motto del Perl :
* TMTOWTDI (Pronounced Tim Toady): "There is more than one way to do it", ossia "c'è più di un modo per farlo".
* Le cose facili debbono restare facili, le difficili più semplici e le impossibili difficili.

=== Gergo
* *Perl 6*: è la specifica di un linguaggio con una test suite.
Le implementazioni che passano la test suite di specifica sono considerate Perl 6.
* *Rakudo*: è un compilatore Perl 6.
* *Rakudobrew*: è un manager d'installazione per Rakudo.
* *Zef*: è un installatore di moduli per Perl 6.
* *Rakudo Star*: è una raccolta che include Rakudo, Zef, una collezione di moduli Perl 6 e della documentazione.

=== Come installare Perl 6
.Linux

Per installare Rakudo Star, lancia questi comandi dal tuo terminale:
----
wget https://rakudo.perl6.org/downloads/star/rakudo-star-2017.04.tar.gz
tar xfz rakudo-star-2017.04.tar.gz
cd rakudo-star-2017.04
perl Configure.pl --gen-moar --prefix /opt/rakudo-star-2017.04
make install
----
Per altre opzioni, vai a http://rakudo.org/how-to-get-rakudo/#Installing-Rakudo-Star-Linux

.macOS
Ci sono quattro opzioni:

* Seguire gli stessi passi indicati per Linux
* Installazione secondo homebrew: `brew install rakudo-star`
* Installazione con MacPorts: `sudo port install rakudo`
* scaricare l'ultimo installer (file con estensione .dmg) from https://rakudo.perl6.org/downloads/star/

.Windows
. Scaricare l'ultimo installer (file con estensione .msi) da https://rakudo.perl6.org/downloads/star/ +
Se la tua architettura è una 32-bit, scarica il file x86; se è una 64-bit, il file x86_64.
. Dopo l'installazione accertati che `C:\rakudo\bin` sia nel PATH

.Docker
. Prendi l'immagine ufficiale per Docker `docker pull rakudo-star`
. Poi fai girare un container con l'immagine `docker run -it rakudo-star`

=== Eseguire codice Perl 6

Eseguire codice Perl 6 può essere fatto usando REPL (Read-Eval-Print Loop).
Per farlo apri un terminale, digita `perl6` e premi [Enter].  
Questo farà apparire il prompt `>`.
Poi digita una linea di codice e digita [Enter].
REPL fornirà il valore della linea. Puoi digitare un'altra linea, oppure `exit`
e premere [Enter] per uscire da REPL.

Alternativamente, scrivi il tuo codice in un file, salvalo e fallo girare.
Si raccomanda che gli script Perl 6 abbiano l'estension `.pl6`.
Fai girare il file digitando `perl6 nomefile.pl6` nel terminale e premi [Enter].
A differenza di REPL, questo non scriverà automaticamente il risultato di
ogni linea: il codice deve contenere una istruzione opportuna (per esempio `say`)
per scrivere un output sul monitor.

REPL in generale si usa per fare delle prove su pezzetti specifici di codice,
tipicamente singole linee. Per programmi con più di una singola linea si raccomanda
di immagazzinarel prima in un file e poi far girare quello.

Linee singole possono essere provate anche non interattivamente sulla linea di comando
attaverso il comando `perl6 -e 'tuo-codice-qui'` e premendo [Enter].

[NOTA]
--
Rakudo Star contiene un editor di liea che permette di fare quasi tutto senza REPL. 

Se hai installato il semplice Rakudo invece di Rakudo Star allor probabilmente non avrai
abilitate le funzionalità di editing  di linea (che sono frecce alto e basso per la storia,
sinistra e destra per editare l'input, completamento con il TAB).
Valuta di far girare i seguenti comandi per avere tutto disponibile:

* `zef install Linenoise` funziona su Windows, Linux e macOS

* `zef install Readline` se sei su Linux e preferisci la libreria _Readline_ library
--

=== Editor
Poiché scriveremo e salveremo il nostro codice Perl 6 per la maggior parte del tempo,
dovremmo avere un buon editor di testo che riconosca la sintassi Perl 6.

Personalmente uso e raccomando https://atom.io/[Atom]. 
Si tratta di un moderno editor di testo che fornisce nativamente riconoscimento sintattico di Perl 6

https://atom.io/packages/language-perl6[Perl 6 FE] è un altro riconoscitore sintattico di Perl 6 per Atom;
è derivato da un package originale corretto e riveduto.

Altre persone della comunità usano anche http://www.vim.org/[Vim], https://www.gnu.org/software/emacs/[Emacs] oppure 
http://padre.perlide.org/[Padre].

Versioni recenti di Vim forniscono il riconoscimento sintattico nativamente.
Emacs e Padre richiederanno invece l'installaizone di package addizionali.

=== Salve Mondo!
Inizieremo dal tradizionale 'salve mondo'

[source,perl6]
say 'salve mondo';

che può anche essere scritto così:

[source,perl6]
'salve mondo'.say;

=== Panoramica sulla sintassi
Perl 6 è *free form*: Sei libero (la maggior parte delle volte) di usare un numero di spazi a piacere.

*Istruzioni* sono tipicamente una linea logica di codice, necessitano di finire con punto e virgola:
`say "Ciao" if True;`

*Espressioni* sono speciali tipi di istruzioni che ritornano un valore:
`1+2` restituirà `3`

Le espressioni sono composte da *Operandi* ed *Operatori*

Gli *operandi* possono essere:

* *Variabili*: un valore che può essere manipolato o cambiato.

* *Costanti*: un valore costante come un numero o una stringa.

Gli *operatore* vengono classificati nei seguenti tipi:

|===

| *Tipo* | *Descrizione* | *Esempio*

| Prefisso | precede l'operando | `++1`

| Infisso | tra operandi | `1+2`

| Postfisso | segue l'operando | `1++`

| Circumfisso | circonda l'operando | `(1)`

| Postcircumfisso | segue un operando, abbraccia l'altro  | `Array[1]`

|===

==== Identificatori
Gli identificatori sono nomi dati agli opernadi quando questi vengono definiti.

.Regole:
* Debbono iniziare con un carattere alfanumerico oppure con un underscore.

* Possono contenere cifre numeriche (eccetto che al primo posto).

* Possono contenere trattini oppure apostrofi (eccetto che al primo o all'ultimo posto), dato che ci deve essere un carattere alfabetico alla destra di ogni trattino o di ogni apostrofo.

|===

| *Corretto* | *Scorretto*

| `var1` | `1var`

| `var-uno` | `var-1`

| `var'uno` | `var'1`

| `var1_` | `var1'`

| `_var` | `-var`

|===

.Notazini convenzionali:
* notazione a cammello: `variabileNo1`

* notazione kebab: `variabile-no1`

* notazione a serpente: `variabile_no1`

Sei libero di nominare i tuoi identificatori come preferisci; è buona pratica adottare una certa notazione in modo uniforme.

Usare nomi significativi facilita la tua vita di programmatore (e quella degli altri!).

* `var1 = var2 * var3` è una istruzione sintatticamente corretta, ma il suo scopo non è di immediata comprensione.
* `salario-mensile = paga-giornaliera * giorni-lavorati` sarebbe un modo milgiore di nominare queste variabili.

==== Commenti
Un commento è un testo che viene ignorato dal compilatore e viene usato come un appunto.

I commenti si dividono in tre tipi:

* su singola linea:
+
[source,perl6]
# questo è un commento su singola linea

* Annidati:
+
[source,perl6]
say #`(questo è un commento annidato) "Salve Mondo."

* Multi-linea:
+
[source,perl6]
-----------------------------
=begin commento
Questo è un commento multilinea.
Commento 1
Commento 2
=end commento
-----------------------------

==== Virgolettato
Le stringhe hanno bisogno di essere delimitate o da doppie virgolette oppure da virgolette singole.

Usa sempre le doppie virgolette se:

* la tua stringa contiene un apostrofo.

* la tua stringa contiene una variabile che deve essere interpolata.

[source,perl6]
-----------------------------------
say 'Salve Mondo';   # Salve Mondo
say "Salve Mondo";   # Salve Mondo
say "l'amo";         # l'amo
my $name = 'John Doe';
say 'Salve $name';   # Salve $name
say "Salve $name";   # Salve John Doe
-----------------------------------

== Operatori

=== Operatori comuni
Nella tabella qui sotto vediamo gli operatori più comunemente usati.
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Operatore | Tipo | Descrizione | Esempio | Risultato

| + | Infisso | Addizione | 1 + 2 | 3

| - | Infisso | Sottrazione | 3 - 1 | 2

| * | Infisso | Moltiplicazione | 3 * 2 | 6

| ** | Infisso | Elevamento a potenza | 3 ** 2 | 9

| / | Infisso | Divisione | 3 / 2 | 1.5

| div | Infisso | Divisione Intera (arrotondamento per difetto) | 3 div 2 | 1

| % | Infisso | Modulo | 7 % 4 | 3

.2+| %% .2+| Infisso .2+| Divisibilità | 6 %% 4 | False

<| 6 %% 3 <| True

| gcd | Infisso | Massimo comune divisore | 6 gcd 9 | 3

| lcm | Infisso | Minimo comune multiplo | 6 lcm 9 | 18

| == | Infisso | Uguaglianza numerica | 9 == 7  | False

| != | Infisso | Disuguaglianza numerica | 9 != 7  | True

| < | Infisso | Minore di | 9 < 7  | False

| > | Infisso | Maggiore di | 9 > 7  | True

| \<= | Infisso | Minore o uguale | 7 \<= 7  | True

| >= | Infisso | Maggiore o uguale | 9 >= 7  | True

| eq | Infisso | Uguaglianza tra stringhe | "Giovanni" eq "Giovanni"  | True

| ne | Infisso | Disuguaglianza tra stringhe | "Giovanni" ne "Giovanna"  | True

| = | Infisso | Assegnamento | my $var = 7  | Assegna il valore di `7` alla variabile `$var`

.2+| ~ .2+| Infisso .2+| Concatenazione tra stringhe | 9 ~ 7 | 97

<m| "Hei " ~ "là"  <| Hei là

.2+| x .2+| Infisso .2+| Replicazione di stringhe | 13 x 3  | 131313

<| "Ciao " x 3  <| Ciao Ciao Ciao

.5+| ~~ .5+| Infisso .5+| Corrispondenza intelligente | 2 ~~ 2  | True

<| 2 ~~ Int <| True

<| "Perl 6" ~~ "Perl 6" <| True

<| "Perl 6" ~~ Str <| True

<| "illuminismo" ~~ /lumi/ <| ｢lumi｣

.2+| ++ | Prefisso | Incremento | my $var = 2; ++$var;  | PRIMA incrementa di 1 la variabile e ritorna il risultato `3`

<m| Postfisso <d| Incremento <m| my $var = 2; $var++;  <| Ritorna la variabile `2` e POI la incrementa

.2+|\--| Prefisso | Decremento | my $var = 2; --$var;  | PRIMA decrementa la variabile di 1 e ritorna il risultato `1`

<m| Postfisso <d| Decremento <m| my $var = 2; $var--;  <| Ritorna la variabile `2` e POI la decrementa

.3+| + .3+| Prefisso .3+| Forza l'operando ad un valore numerico | +"3"  | 3

<| +True <| 1

<| +False <| 0

.3+| - .3+| Prefisso .3+| Forza l'opernaod ad un valroe numerico e ne ritorna la negazione | -"3"  | -3

<| -True <| -1

<| -False <| 0

.6+| ? .6+| Prefisso .6+| Forza l'operando ad un valore booleano | ?0 | False

<| ?9.8 <| True

<| ?"Ciao" <| True

<| ?"" <| False

<| my $var; ?$var; <| False

<| my $var = 7; ?$var; <| True

| ! | Prefisso | Forza l'operando ad un valore booleano e ne ritorna la negazione | !4 | False

| .. | Infisso | Intervallo |  0..5  | Crea un intervallo da 0 a 5

| ..^ | Infisso | Intervallo con estremo escluso |  0..^5  | Crea un intervallo da 0 a 4

| ^.. | Infisso | Intervallo con estremo escluso |  0^..5  | Crea un intervallo da 1 a 5

| \^..^ | Infisso | Intervallo con estremi esclusi |  0\^..^5  | Crea un intervallo da 1 a 4

| ^ | Prefisso | Intervallo unario |  ^5  | Come fosse 0..^5; crea un intervallo da 0 a 4

| ... | Infisso | Costruttore pigro di liste |  0...9999  |  ritorna gli elementi solo se richiesti

.2+| {vbar} .2+| Prefisso .2+| Spalmatore | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

=== Operatori inversi

Aggiungendo una `R` prima di ogni operatore si rovesceranno i suoi operandi.

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Operazione normale | Risultato | Operazione inversa | Risultato

| 2 / 3 | 0.666667 | 2 R/ 3 | 1.5

| 2 - 1 | 1 | 2 R- 1 | -1

|===

=== Operatori di riduzione

Gli operatori di riduzione lavorano su liste di valori.
Si formano avvolgendo l'operatore tra parentesi quadre `[]`

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Operazione normale | Risultato | Operatore di riduzione | Risultato

| 1 + 2 + 3 + 4 + 5 | 15 | [+] 1,2,3,4,5 | 15

| 1 * 2 * 3 * 4 * 5 | 120 | [*] 1,2,3,4,5 | 120

|===

NOTA: Per vedere una lista completa degli operatori, incluse le precedenze tra di loro, vai qui https://docs.perl6.org/language/operators

== Variabili
Le variabili Perl 6 sono classificate in tre categorie: scalari, array e hash.

Un *sigillo* è un carattere che viene usato come prefisso per categorizzare le variabili.

* `$` per gli scalari
* `@` per gli array
* `%` per gli hash

=== Scalari
Gli scalari portano un singolo valore oppure un puntatore.

[source,perl6]
----
# Stringa
my $name = 'John Doe';
say $name;

# Interi
my $anni = 99;
say $anni;
----

Sugli scalari si può applicare un gruppo specifico di operazioni, dipendentemente dal valore che portano.

[source,perl6]
.Stringhe
----
my $name = 'John Doe';
say $name.uc;
say $name.chars;
say $name.flip;
----

----
JOHN DOE
8
eoD nhoJ
----

NOTA: Per avere una lista completa dei metodi applicabili alle stringhe, vedi qui https://docs.perl6.org/type/Str

[source,perl6]
.Interi
----
my $anni = 17;
say $anni.is-prime;
----

----
True
----

NOTA: Per avere una lista completa dei metodi applicabili agli interi vei qui https://docs.perl6.org/type/Int

[source,perl6]
.Numeri razionali
----
my $age = 2.3;
say $age.numerator;
say $age.denominator;
say $age.nude;
----

----
23
10
(23 10)
----

NOTA: Per una lista completa dei metodi applicabili ai numeri razionali vedi qui https://docs.perl6.org/type/Rat

=== Array
Gli array (alias vettori, liste etc ndt.) sono liste contenenti valori multipli.

[source,perl6]
----
my @animali = 'cammello','lama','gufo';
say @animali;
----

Sugli array si possono fare un sacco di perazioni, come mostrato nell'esempio sottostante:

Noticina: La tilde `~` si usa per la concatenazione delle stringhe.

[source,perl6]
.`Script`
----
my @animali = 'cammello','vigogna','lama';
say "Nello zoo ci sono " ~ @animali.elems ~ " animali";
say "Gli animali sono: " ~ @animali;
say "Adotterò un gufo per lo zoo";
@animali.push("gufo");
say "Ora il mio zoo ha: " ~ @animali;
say "Il primo animale adottato fu " ~ @animali[0];
@animali.pop;
say "Sfortunatamente il gufo è volato via e siamo rimasti con: " ~ @animali;
say "Stiamo chiudendo lo zoo tenendo un solo animale";
say "Stiamo lasciando andare: " ~ @animali.splice(1,2) ~ " e teniamo il " ~ @animali;
----

.`Output`
----
Nello zoo ci sono 3 animali
Gli animali sono: cammello vigogna lama
Adotterò un gufo per lo zoo
Ora il mio zoo ha: cammello vigogna lama gufo
Il primo animale adottato fu il cammello
Sfortunatamente il gufo è volato via e siamo rimasti con: cammello vigogna lama
Stiamo chiudendo lo zoo tenendo un solo animale
Stiamo lasciando andare: vigogna lama e teniamo il cammello 
----

.Spiegazione
`.elems` ritorna il numero degli elementi di un array. +
`.push()` aggiunge uno o più elementi all'array. +
Possiamo accedere ad uno specifico elemento dell'array specificando la sua posizione `@animali[0]`. +
`.pop` rimuove l'ultimo elemento dell'array e lo restituisce. +
`.splice(a,n)` rimuove `n` elmenti iniziando dalla posizione `a`.

==== array a dimensione fissata
Un array semplice viene dichiarato così:
[source,perl6]
my @array;

L'array semplice può avere una lunghezza qualsiasi e per questo viene chiamato auto-estensibile. +
L'array accetta qualsiasi numero di valori, senza restrizioni.

Al contrario, possiamo creare array a dimesione fissata. +
Questi array non possono ricevere accessi oltre la dimensione data.

Per dichiarare un array di dimensione fissata devi specificare il massimo numero di elementi tra parentesi quadre subito dopo il suo nome:
[source,perl6]
my @array[3];

Questo array potrà tenere al massimo tre valori, indicizzati da 0 a 2.

[source,perl6]
----
my @array[3];
@array[0] = "primo valore";
@array[1] = "secondo valore";
@array[2] = "terzo valore";
----

Non potrai aggiungere un quarto valore:
[source,perl6]
----
my @array[3];
@array[0] = "primo valore";
@array[1] = "secondo valore";
@array[2] = "terzo valore";
@array[3] = "quarto valore";
----


Otterresti il seguente messaggio di errore: 
[source,perl6]
----
Index 3 for dimension 1 out of range (must be 0..2) 
----

==== Array multidimensionali
Gli array che abbiamo visto sono monodimensionali. +
Fortunatamente possiamo definirne anche di multidimensionali in Perl 6.

[source,perl6]
my @tbl[3;2];

Questo array è mulitidimensionale.
La prima dimensione può avere un massimo di tre valori e la seconda un massimo di due.

Pensa ad una griglia 3x2.

[source,perl6]
----
my @tbl[3;2];
@tbl[0;0] = 1;
@tbl[0;1] = "x";
@tbl[1;0] = 2;
@tbl[1;1] = "y";
@tbl[2;0] = 3;
@tbl[2;1] = "z";
say @tbl
----

----
[[1 x] [2 y] [3 z]]
----

.Rappresentazione visuale di un array:
----
[1 x]
[2 y]
[3 z]
----

NOTA: Per avere una guida completa sugli array vedi qui https://docs.perl6.org/type/Array

=== Hash
[source,perl6]
.Un hash è un insime di coppie chiave/valore.
----
my %capitali = ('Italia','Roma','Germania','Berlino');
say %capitali;
----

[source,perl6]
.Un altra forma, più succinta, di popolare un hash:
----
my %capitali = (Italia => 'Roma', Germania => 'Berlino');
say %capitali;
----

Alcuni metodi che possono essere applicati agli hash:
[source,perl6]
.`Script`
----
my %capitali = (Italia => 'Roma', Germania => 'Berlino');
%capitali.push: (Francia => 'Parigi');
say %capitali.kv;
say %capitali.keys;
say %capitali.values;
say "La capitale della Francia è: " ~ %capitali<Francia>;
----

.`Output`
----
(Francia Parigi Germania Berlino Italia Roma)
(Francia Germania Italia)
(Parigi Berlino Roma)
La capitale della Francia è: Parigi
----

.Spiegazione
`.push: (chiave => 'valore')` aggiunge una nuova coppia chiave/valore. +
`.kv` ritorna una lista contenente tutte le chiavi ed i valori. +
`.keys` ritorna una lista contenente tutte le chiavi. +
`.values` ritorna una lista contenente tutti i valori. +
Possiamo accedere ad uno specifico valore nell'hash specificando la sua chaive, così `%hash<key>`

NOTA: Per avere una guida completa sugli hash vedi qui https://docs.perl6.org/type/Hash

=== Tipi
Nei precedenti esempi non abbiamo specificato che tipo di valori le variabili dovrebbero contenere.

Noticina: `.WHAT` ritornerà il tipo di valore contentuo in una variabile.

[source,perl6]
----
my $var = 'Text';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
----

Come puoi vedere nell'esempio qui sopra, il tipo di valore in `$var` prima era (Str) e poi è diventato (Int).

Questo stile di programmazionie viene chiamato tipizzazione dinamica. Dinamica nel senso che le variabili possono contenere valori di ogni tipo (tipo Any ndt).

Prova a far girare questo esempio: +
Nota `Int` prima del nome della variabile.

[source,perl6]
----
my Int $var = 'Text';
say $var;
say $var.WHAT;
----

Fallirà con questo messaggio di errore: `Type check failed in assignment to $var; expected Int but got Str` 
 controllo sul tipo fallito per $var; mi aspettavo un Int ma ho ricevuto Str]

Ciò che è successo è che abbiamo specificato che la variabile avrebbe dovuto essere di un tipo (Int), ma quando l'abbiamo assegnata ad una stringa è fallita.

Questo stile di programmazione si chiama tipizzazione statica. Statica nel senso che i tipi delle variablili sono definiti prima degli assegnamenti e non possono più cambiare.

Il Perl 6 è classificato come *gradualmente tipizzato*; esso permette sia la tipizzazione *statica* che quella *dinamica*.

.Anche array ed hash possono essere tipizzati staticamente:
[source,perl6]
----
my Int @array = 1,2,3;
say @array;
say @array.WHAT;

my Str @multilingual = "Ciao","Salut","Hallo","您好","안녕하세요","こんにちは";
say @multilingual;
say @multilingual.WHAT;

my Str %capitali = (Italia => 'Roma', Germania => 'Berlino');
say %capitali;
say %capitali.WHAT;

my Int %country-codes = (Italia => 39, Germania => 49);
say %country-codes;
say %country-codes.WHAT;
----

.Qui sotto una lista dei tipi più comunemente usati:
Probabilmente non userai mai i primi due ma essi vengono inclusi in questa lista per completezza.

[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Tipo* | *Descrizione* | *Esempio* | *Risultato*

| Mu | La radice della gerarchia dei tipi del Perl 6 | |

| Any | Classe base per nuove classi e per la maggior parte delle classi predefinite | |

| Cool | Valore che può essere trattato indifferentemente come una stringa oppure come un numero | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | Stringa di caratteri | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Intero (precisioine arbitraria) | 7 + 7 | 14

| Rat | Numero razionale (precisione limitata) | 0.1 + 0.2 | 0.3

| Bool | Booleano | !True | False

|===

=== Introspezione

Introspezione è il processo per cui si ottiene una informazione sulle proprietà di un oggetto, come il tipo. +
In un esempio precedente abbiamo usato `.WHAT` per ottenere il tipo di una variabile.

[source,perl6]
----
my Int $var;
say $var.WHAT;    # (Int)
my $var2;
say $var2.WHAT;   # (Any)
$var2 = 1;
say $var2.WHAT;   # (Int)
$var2 = "Hello";
say $var2.WHAT;   # (Str)
$var2 = True;
say $var2.WHAT;   # (Bool)
$var2 = Nil;
say $var2.WHAT;   # (Any)
----

Il tipo di una variabile che contiene un valore è correlato a tale valore. +
Il tipo di una variabile vuota dichiarata staticamente è il tipo con il quale è stata dichiarata. +
Il tipo di una variabile vuote che non è stata dichiarata staticamente è `(Any)` +
Per cancellare il valroe di una variabile assegnale `Nil`.

=== Ambito
Prima di usare una variabile per la prima volta essa deve essere dichiarata.

Several declarators are used in Perl 6. We've been using `my`, so far.

[source,perl6]
my $var=1;

The `my` declarator give the variable *lexical* scope.
In other words, the variable will only be accessible in the same block it was declared.

A block in Perl 6 is delimited by `{ }`.
If no block is found, the variable will be available in the whole Perl 6 script.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;   # is accessible
}
say $var;   # is not accessible, returns an error
----

Since a variable is only accessible in the block where it is defined, the same variable name can be used in another block.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Assegnamenti e vincoli
Abbiamo visto negli esempi precedenti come *assegnare valori alle variabili. +
Un *assegnamento* viene fatto tramite l'operatore `=`.
[source,perl6]
----
my Int $var = 123;
say $var;
----

IL valore assegnato ad una variabile si può cambiare:

[source,perl6]
.Assegnamento
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Output`
----
123
999
----

D'altro canto, non possiamo cambiare il valore di una variabile quando questo è *vincolato*. +
Il *vincolo* viene definito tramite l'operatore `:=`.

[source,perl6]
.Vincolo
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Output`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.le variabili possono anche essere vincolate ad altre variabli:
----
my $a;
my $b;
$b := $a;
$a = 7;
say $b;
$b = 8;
say $a;
----

.`Output`
----
7
8
----

Vincolare le variabili è bidirezionale. +
`$a := $b` and `$b := $a` hanno lo stesso effetto.

NOTA: Per avere più informazioni sulle variabli vedi qui https://docs.perl6.org/language/variables

== Funzioni e modificatori

Ci sono differenze tra funzioni e modificatori. +
Le funzioni non cambiano lo stato dell'oggetto su cui vengono chiamate ad operare. +
I modificatori sì.

[source,perl6,linenums]
.`Script`
----
my @numeri = [7,2,4,9,11,3];

@numeri.push(99);
say @numeri;      #1

say @numeri.sort; #2
say @numeri;      #3

@numeri.=sort;
say @numeri;      #4
----

.`Output`
----
[7 2 4 9 11 3 99] #1
(2 3 4 7 9 11 99) #2
[7 2 4 9 11 3 99] #3
[2 3 4 7 9 11 99] #4
----

.Spiegazione
`.push` è un modificatore; esso cambia lo stato dell'array (#1)

`.sort` è una funzione; essa ritorna un array ordinato ma non modifica lo stato iniziale dell'array:

* (#2) mostra che viene ritornato un array ordinato.

* (#3) mostra che l'array iniziale è rimasto immutato.

Per forzare una funzione a comportarsi da modificatore usiamo `.=` invece di `.` (#4) (linea 9 dello script)

== Cicli e condizioni
Perl 6 ha molti costrutti condizionali e ciclici.

=== if
Il codice gira solo se la condizione specificata viene soddisfatta, ossia una espressione viene valutata come `True`.

[source,perl6]
----
my $anni = 19;

if $anni > 18 {
  say 'Benvenuto'
}
----

In Perl 6, possiamo invertire il codice condizionato e la condizione. +
Anche se il codice e la condizione vengono invertiti, la condizione viene sempre valutata per prima.

[source,perl6]
----
my $anni = 19;

say 'Benvenuto' if $anni > 18;
----

Se la condizione non viene soddisfatta, possiamo specificare blocchi da eseguire in alternativa usando:

* `else`
* `elsif`

[source,perl6]
----
# fai girare lo stesso codice per valori dfferenti della variabile
my $numero_di_posti = 9;

if $numero_di_posti <= 5 {
  say 'sono una berlina'
} elsif $numero_di_posti <= 7 {
  say 'sono una station'
} else {
  say 'sono un furgone'
}
----

=== unless
La versione negata di una istruzione `if` può essere `unless`.

Il codice seguente:

[source,perl6]
----
my $scarpe-pulite = False;

if not $scarpe-pulite {
  say 'Pulisciti le scarpe'
}
----
può essere scritto così:

[source,perl6]
----
my $scarpe-pulite = False;

unless $scarpe-pulite {
  say 'Pulisciti le scarpe'
}
----

La negazione, in Perl 6, viene fatta usando o `!` o `not`.

`unless (codizione)` viene usato al posto di `if not (condizione)`.

`unless` non può avere una clausola di alternativa `else`.

=== with

`with` si comporta come `if`, ma controlla se la variabile sia definita.

[source,perl6]
----
my Int $var=1;

with $var {
  say 'Ciao'
}
----

Se fai girare il codice senza assegnare una valore alla variabile, non accade nulla.
[source,perl6]
----
my Int $var;

with $var {
  say 'Ciao'
}
----

`without` è la versione negata di `with`. Puoi vederne un'analogia di `unless`.

se il primo `with` non viene soddisfatto, si può specificare un percorso alternativo con `orwith`. +
`with` ed `orwith` sono analoghi ad `if` ed `elsif`.

=== for

Il ciclo `for` itera su valori multipli.

[source,perl6]
----
my @array = [1,2,3];

for @array -> $array-item {
  say $array-item * 100
}
----

Nota che abbiamo creato una variabile di iterazione `$array-item` e poi eseguito l'operazione `*100` su ogni occorrenza della stessa.

=== given

`given` è l'equivalente Perl 6 dell'istruzione switch che si trova in altri linguaggi,
ma molto più potente.

[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'minore di o uguale a 50'}
    when Int { say "è un Int" }
    when 42  { say 42 }
    default  { say "eh?" }
}
----

A seguito di una condizione soddisfatta, il processo di confronto si interrompe.

L'alternativa è usare `proceed` che dice a Perl 6 di continuare i confronti anche dopo un successo.
[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'minore di o uguale a 50';proceed}
    when Int { say "è un Int";proceed}
    when 42  { say 42 }
    default  { say "eh?" }
}
----

=== loop

`loop` è un altro modo di scrivere un ciclo `for`.

In realtà `loop` sarebbe il `for` per come è scritto nei linguaggi di programmazione della famiglia che si rifà al C.

Infatti il Perl 6 appartiene a tale famiglia.

[source,perl6]
----
loop (my $i = 0; $i < 5; $i++) {
  say "Il numero corrente è $i"
}
----

NOTA: Per avere più informazioni su cicli e costrutti condizioniali vedi qui https://docs.perl6.org/language/control

== I/O
In Perl 6 due delle più comuni interfacce di _Input/Output_ sono il _terminale_ ed i _file_.

=== I/O essenziale usando il terminale

==== say
`say` scrive sullo standard output. Aggiunge un a-capo alla fine. In altre parole il seguente codice:

[source,perl6]
----
say 'Salve Signora.';
say 'Salve Signore.';
----
viene scritto su due linee separate.

==== print
`print` invece si comporta come `say` ma senza aggiungere l'a-capo.

Prova a sostituire `say` con `print` e confronta i risultati.

==== get
`get` viene usato per catturare l'ingresso dal terminale.

[source,perl6]
----
my $name;

say "Ciao, come ti chiami?";
$name = get;

say "Caro $name benvenuto al Perl 6";
----

Quando il codice qui sopra viene eseguito il terminale aspetterà che tu inserisca un nome. Poi premi [Enter].
In questo modo ti saluterà.

==== prompt
`prompt` è una combinazione di `print` e `get`.

L'esempio sopra può essere scritto così:

[source,perl6]
----
my $nome = prompt "Ciao come ti chiami? ";

say "Caro $nome benvenuto a Perl 6";
----

=== Eseguire comandi shell
Si possono usare due subroutine per far girare comandi shell:

* `run` Fa girare un comando esterno senza coinvolgere shell.

* `shell` Fa girare un comando mediante una vera system shell; esso dipende sia dalla shell di sistema sia dalla piattaforma.
Tutti i meta caratteri tipici della shell verranno interpretati proprio dalla shell di sistema, inclusa pipe, ridirezione, variabili di ambiente, sostituzioni ecc.

[source,perl6]
.Fai girare questo codice se lavori su piattaforma Linux/macOS
----
my $nome = 'Neo';
run 'echo', "ciao $nome";
shell "ls";
----

[source,perl6]
.Fai girare questo se lavori su piattaforma Windows
----
shell "dir";
----
`echo` ed `ls` sono comandi Linux: +
`echo` stampa un testo su terminale (equivalente a `say` in Perl 6) +
`ls` lista tutti i file e le cartelle del direttorio corrente

`dir` equivale a `ls` quando sei su Windows.


=== File I/O
==== slurp
`slurp` si usa per leggere dati da un file.

Crea un file di testo con il seguente contenuto:

.datafile.txt
----
Giovanni 9
Giovannino 7
Giovanna 8
Gianna 7
----
[source,perl6]
----
my $data = slurp "datafile.txt";
say $data;
----

==== spurt
`spurt` si usa per scrivere dati in un file.

[source,perl6]
----
my $nuovodato = "nuovi punti:
Paul 10
Paulie 9
Paulo 11";

spurt "nuovodatafile.txt", $nuovodato;
----

Dopo aver fatto girare il codice qui sopra avremo un nuovo file _nuovodatafile.txt_ ; esso conterrà i nuovi punti.

=== Lavorare con file e cartelle
Perl 6 può listare il contentuo di una cartella senza ricorrere alla shell di comando (per esempio se vogliamo fare un `ls`).

[source,perl6]
----
say dir;                # Lista di file e cartelle nel direttorio corrente
say dir "/Documents";   # Lista di file e cartelle nel direttorio specificato
----

In oltre puoi creare e cancellare cartelle.

[source,perl6]
----
mkdir "nuovacartella"; # crea una nuova cartella
rmdir "nuovacartella"; # cancella una cartella vuota e ritorna un errore se non è vuota
----

Puoi anche controllare se un certo percorso esista; puoi controllare se sia un file, oppure una cartella:

Nella cartella dove farai girare lo script sottostante, crea prima una sottocartella vuota chiamata `cartella123` e crea anche un file vuoto chiamato `script123.pl6`

[source,perl6]
----
say "script123.pl6".IO.e;
say "cartella123".IO.e;

say "script123.pl6".IO.d;
say "cartella123".IO.d;

say "script123.pl6".IO.f;
say "cartella123".IO.f;
----

`IO.e` controlla che la cartella o il file esistano. +
`IO.f` controlla che il percorso sia un file. +
`IO.d` controlla che il percorso sia una cartella.

ATTENZIONE: Gli utenti Windows possono usare sia `/` che `\\` per definire le cartelle +
`C:\\rakudo\\bin` +
`C:/rakudo/bin` +

NOTA: Per avere più informazioni sull'I/O vedi qui https://docs.perl6.org/type/IO

== Funzioni o metodi
=== Definizioni
Le *Subroutine* (chiamate anche *sub* o *funzioni* o *procedure* o *metodi*) sono strumenti per riutilizzare delle specifiche funzionalità. +

La definizione di una subroutine inizia con la parola chiave `sub`. Dopo la loro definizione possono essere chiamate tramite il loro identificativo. +
Prova questo esempio:

[source,perl6]
----
sub saluto-alieno {
  say "Salve terrestri";
}

saluto-alieno;
----

L'esempio precedente mostra una subroutine che non richiede alcun input.

=== Firma
Le subroutine possono richiedere un input. Tali input vengono forniti tramite *argomenti*. Gli argomenti sono anche detti *parametri*. Il numero ed il tipo di parametri che una subroutine definisce viene chiamato *firma*.

La subroutine qui sotto accetta un argomento di tipo stringa.

[source,perl6]
----
sub saluta (Str $nome) {
    say "Ciao " ~ $name ~ "!!!!"
}
saluta "Paolo";
saluta "Paola";
----

=== Indirizzamento multiplo (overload)
Ci possono essere subroutine che hanno lo stesso nome ma firme diverse.
Quando si chiama una subroutne, l'ambiente di esecuzione decide quale versione usare basandosi sul numero e sul tipo degli argomenti forniti. Questo tipo di subroutine è definito nello stesso modo con cui si definiscono le normali sub eccetto per il fatto che usiamo la parola chiave `multi` al posto dell'originale `sub`.

[source,perl6]
----
multi saluti($nome) {
    say "Buongiorno $nome";
}
multi saluti($nome, $titolo) {
    say "Buongiorno $titolo $nome";
}

saluti "Giovannino";
saluti "Laura","Signora";
----

=== Parametri opzionali e mancanti
Se una subroutine viene definita per accettare un argomento e noi invece la chiamiamo senza fornire tale argomento avremo un fallimento.

Perl 6 allora fornisce la possiblilità di definire:

* Parametri opzionali
* Parametri mancanti

I parametri opzionali vengono definiti aggiungendo `?` al nome del parametro.

[source,perl6]
----
sub saluta($nome?) {
  with $nome { say "Ciao " ~ $nome }
  else { say "Ciao" }
}
saluta;
saluta("Laura");
----

Se non hai bisogno di fornire un argomento, puoi definirne uno in caso di mancanza. +
Per farlo assegni un valore al tuo parametro in fase di definizione.

[source,perl6]
----
sub saluta($nome="Matteo") {
  say "Ciao " ~ $name;
}
saluta;
saluta("Laura");
----

=== Restituire valori
Tutte le subroutine che abbiamo visto *fanno qualcosa* -- scrivono del testo al terminale.

Talvolta, tuttavia, eseguiamo subroutine perché ci *restituiscano* un valore con il fino di usarlo nei passi successivi del nostro programma.

Se una funzione giunge alla fine del suo blocco, l'ultima istruzione o espressione determinerà il valore di ritorno; è il *ritorno implicito*

[source,perl6]
.Ritorno implicito
----
sub quadrato ($x) {
  $x ** 2;
}
say "7 a quadrato è uguale a " ~ quadrato(7);
----

Per leggibilità e pulizia del codice, potrebbe essere bene specificare _esplicitamente_ che cosa viene restituito; usiamo allora la parola chiave `return`; è il *ritorno esplicito*
[source,perl6]
.Ritorno esplicito
----
sub quadrato ($x) {
  return $x ** 2;
}
say "7 al quadrato è uguale a " ~ quadrato(7);
----
==== Vincolare i valori di ritorno
In un esempio precedente abbiamo visto come possiamo vincolare gli argomenti ad essere di un certo tipo.
Possiamo fare lo stesso con i valori di ritorno.

Per vincolare il valore di ritorno ad un certo tipo, possiamo usare la parola chiave `returns` oppure la notazione a freccia `-\->`.

[source,perl6]
.uso di returns
----
sub quadrato ($x) returns Int {
  return $x ** 2;
}
say "1.2 al quadrato è uguale a " ~ quadrato(1.2);
----

[source,perl6]
.uso della notazione a freccia
----
sub quadrato ($x --> Int) {
  return $x ** 2;
}
say "1.2 al quadrato è uguale a " ~ quadrato(1.2);
----
Se sbagliamo a fornire un valore di ritorno che sia allineato con il vincolo di tipo, avremo un errore di questo tipo.

----
Type check failed for return value; expected Int but got Rat (1.44)
----

[Noticina]
====
Il vincolo sul tipo può fare un controllo aggiuntivo: la sua definitezza.

Negli esempi precedente abbiamo specificato che il valore atteso doveva essere Int.

Possiamo specificare anche che il valore da ritornare debba essere strettamente definito (oppure indefinito) usando queste notazioni: +
`-\-> Int:D` e `-\-> Int:U`

Ossia, è buona pratica usare questo tipo di vincoli. +
Qui sotto la versione modificata degll'esempio precedente che usa la faccina `:D` per vincolare l'intero ritornato ad essere anche definito.

[source,perl6]
----
sub quadrato ($x --> Int:D) {
  return $x ** 2;
}
say "1.2 al quadrato è uguale a " ~ quadrato(1.2);
----
====

NOTA: Per avere più informazioni su procedure e funzioni vedi qui https://docs.perl6.org/language/functions

== Programmazione funzionale
In questo capitolo daremo un'occhiata ad alcune funzionalità orientate alla programmazione funzionale.

=== I metodi sono cittadini di prima classe
I metodi sono cittadini di prima classe:

* possono essere passate come argomenti

* possono essere ritornate da altre funzini

* possono essere assegnae a variabili

Un ottimo esempio di questo è la funzione `map`. +
`map` è una _funzione di alto livello_, può accettare un'altra funzione come agomento.

[source,perl6]
.Script
----
my @vettore = <1 2 3 4 5>;
sub quadrato($x) {
  $x ** 2
}
say map(&quadrato,@vettore);
----

.Output
----
(1 4 9 16 25)
----

.Spiegazione
Abbiamo definito la subroutine `quadrato` che prende un argomento e lo eleva al quadrato. +
Poi abbiamo usato `map`, una funzione di alto livello, e le abbiamo passato due argomenti: la funzione `quadrato` ed un vettore di interi. +
Il risultato è un vettore di elementi al quadrato.

Nota che per passare la funzione come argomento abbiamo avuto bisogno di anteporle `&`.

=== Funzioni anonime
Una funzione anonime non è legata ad un identificatore, non ha un nome.
Una *funzione anonima* si chiama anche *lambda*. +

Proviamo a riscrivere l'esempio `map` ed usiamo una funzione anonima
[source,perl6]
----
my @vettore = <1 2 3 4 5>;
say map(-> $x {$x ** 2},@vettore);
----
Nota che invece di dichiarare la funzioine `quadrato` e passarla come argomento a `map` abbiamo invece definitio questa funzione anonima `\-> $x {$x ** 2}`.

Nel gego del Perl 6 quesa notazione si chiama `blocco a punta`.

[source,perl6]
.Un blocco a punta può essere usato per assegnare funzioni a variabili:
----
my $quadrato = -> $x {
  $x ** 2
}
say $quadrato(9);
----

=== Concatenazione
In Perl 6 i metodi possono essere concatenati: in tal modo non è più necessario passare il risultato di un metodo ad un altro come argomento.

Per esempio: Dato un array, puoi voler ritornare i valori unici dell'array, ordinati dal maggiore al minore.

Questa è la soluzione _senza concatenazione_:

[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array = reverse(sort(unique(@array)));
say @final-array;
----
Qui chiamiamo la procedura `unique` su `@array`, e passiamo il risultato come argomento a `sort`, e poi passiamo il risultato a `reverse`.

Al contrario, usando i metodi concatenati, l'esempio sopra può essere riscritto così:

[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array = @array.unique.sort.reverse;
say @final-array;
----

_molto più leggibile_!

=== Operatore alimentazione
L' *operatore alimentazione*, chiamato _pipe_ in alcuni linguaggi di programmazione funzionale, illustra ulteriormente le tecniche di concatenazione.

[source,perl6]
.Alimentazione in avanti (o finale)
----
my @array = <7 8 9 0 1 2then sort it 4 3 5 6 7 8 9>;
@array ==> unique()
       ==> sort()
       ==> reverse()
       ==> my @final-array;
say @final-array;
----

.Spiegazione
----
Inizi con `@array` poi restituisci una lista di elementi unici
                   poi li ordini
                   poi inverti questo ordine
                   poi li memorizzi nel risultato @final-array
----
Qui il metodo delle chiamate è `top-down` -- dal primo passo all'ultimo.


[source,perl6]
.Alimentazione inversa (o causale)
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9>;
my @final-array-v2 <== reverse()
                   <== sort()
                   <== unique()
                   <== @array;
say @final-array-v2;
----

.Spiegazione
Nella sostanza l'alimentazione inversa è identica a quella in avanti. +
Il flusso si inverte, dal passo finale al primo passo.

=== Operatore iper
L' *operatore iper* `>>.` chiama un metodo su tutti gli elementi di una lista e ritorna la lista dei risultati.
[source,perl6]
----
my @array = <0 1 2 3 4 5 6 7 8 9 10>;
sub est-pari($var) { $var %% 2 };

say @array>>.is-prime;
say @array>>.&est-pari;
----

Usando l'operatore iper possiamo chiamare i metodi predefiniti in Perl 6, per esempio `is-prime` che ci dice se un numero è primo oppure no. +
Inoltre possiamo definire nuove subroutine e chiamarle usando l'operatore iper. In questo caso dobbiamo anteporre `&` al nome del metodo; per esempio `&is-even`.

Questo è molto comodo e ci solleva dal dover scrivere cicli `for` per iterare su ogni valore.

ATTENZIONE: Perl 6 garantisce che l'ordine dei risultati sia lo stesso di quello della lista originale.
Tuttavia non c'è garnzia che Perl 6 chiami i metodi nell'ordine della lista, oppure all'interno dello stesso thread. Quindi dobbiamo stare attenti con i metodi che hanno effetti collaterali come `say` o `print`.

=== Giunzioni
Una *giunzione* è una sovrapposizione logica di valori.

Nell'esempio qui sotto `1|2|3` è una giunzione.
[source,perl6]
----
my $var = 2;
if $var == 1|2|3 {
  say "La variabile è 1 o 2 o 3"
}
----
L'uso di giunzioni nomalmente scatena l'*autothreading*; 
ossia, l'operazione viene eseguita per ogni valore della giunzione e tutti i risultati vengono combinati in una nuova giunzione e ritornati.

=== Liste pigre
Una *lista pigra* è una lista che viene valutata con pigrizia. +
Valutare con pigrizia significa ritardala la valutazione di una espressione fino a che essa non venga richiesta ed evita di ripetere valutazioni su valutazioni immagazzinando i risultati in una tabella predittiva.

I benefici includono:

* Miglioramento delle prestazioni evitando calcoli inutili

* La capacità di contruire strutture potenzialmente infinite

* La capacità di definire il flusso di controllo

Per costruire una lista pigra usiamo l'operatore `...` +
Una lista pigra ha uno o più *elementi iniziali*, un *generatore* ed un *punto finale*.

[source,perl6]
.Lista pigra semplice
----
my $lazylist = (1 ... 10);
say $lazylist;
----
L'elemento iniziale è 1 ed il punto finale è 10. Qui non viene definito alcun gneeeratore quindi il generatore è il successore (+1) +
In altre parole la lista pigra può ritornare (se richiesti) i seguenti elementin (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

[source,perl6]
.Lista pigra infinita
----
my $lazylist = (1 ... Inf);
say $lazylist;
----
Questa può ritornare (se richiesto) un intero tra 1 ed infinito, in altre parle un numero naturale.

[source,perl6]
.Lista pigra costruita usando un generatore dedotto
----
my $lazylist = (0,2 ... 10);
say $lazylist;
----
Gli elementi iniziali sono 0 e 2 ed il punto di fine è 10.
Non viene definito alcun generatore, ma usando gli elementi iniziali, Perl 6 dedurrà che il generatore è (+2) +
Questa lista pigra può ritornare (se richiesti) i seguenti elementi (0, 2, 4, 6, 8, 10)

[source,perl6]
.Lista pigra costruita usando un generatore definito
----
my $lazylist = (0, { $_ + 3 } ... 12);
say $lazylist;
----
In questo esempio abbiamo definito esplicitamente il generatore abbacciandolo tra le `{ }` +
Questa lista pigra può ritornare (se richiesti) i seguenti elementi (0, 3, 6, 9, 12)

[Attenzione]
====
Quando usiamo un generatore esplicito, il punto di fine deve essere uno dei valori che il generatore può ritornare. +
Se riproduciamo l'esempio di prima con un punto di fine che sia 10 invece di 12, esso non si fermerà mai.
il generatore _salta oltre_ il punto di fine.

Come alternativa puoi sostituire`0 ... 10` con `0 ...^ * > 10` +
Questa notazione si può leggere in questo modo: da 0 fino al primo valore maggiore di 10 (escluso tale valore)

[source,perl6]
.Questo non fermerà il generatore
----
my $lazylist = (0, { $_ + 3 } ... 10);
say $lazylist;
----

[source,perl6]
.Questo fermerà il generatore
----
my $lazylist = (0, { $_ + 3 } ...^ * > 10);
say $lazylist;
----
====

=== Chiusure
Tutti gli oggetti di Perl 6 sono chiusure, ossia essi possono riferirsi a variabili lessicali da un ambito più esterno.

[source,perl6]
----
sub genera-saluti {
    my $nome = "Giovanni Dossi";
    sub saluti {
      say "Buongiorno $name";
    };
    return &saluti;
}
my $saluto-generato = genera-saluti;
$saluto-generato();
----

Quando fai girare il codice qui sopra, esso scriverà `Buongiorno Giovanni Dossi` sul terminale. +
Mentre il risultato è giustamente semplice, ciò che è interessante in questo esempio, è che la subroutine interna `saluti` venga ritornata da una routine esterna prima di essere eseguita. 

`$saluto-generato` è diventata una *chiusura*.

Una *chiusura* è uno speciale tipo di oggetto che combina due cose:

* Una subroutine

* L'ambiente in cui tale subroutine è stata creata

L'ambiente consiste in qualsiasi variabile locale che era all'interno dell'ambito al momento in cui la chiusura è stata creata. In questo esempio specifico, `$saluto-generato` è una chiusura che incorpora sia la funzione `saluti` che la stringa `Giovanni Dossi` che esisteva quando la chiusura era stata creata.

Vediamo ora un esempio più interessante.
[source,perl6]
----
sub genera-saluti($periodo) {
  return sub ($nome) {
    return "Buon $periodo $nome"
  }
}
my $giorno = genera-salut("giorno");
my $natale = genera-salut("Natale");

say $morning("Giovanni");
say $evening("Giovanna");
----
In questo esempio abbiamo definito un metodo `genera-saluti($periodo)` che accetta un argomento singolo `$periodo` e ritorna una nuova funzione. Tale funzione accetta un argomento singolo `$nome` e ritorna un saluto.

Essenzialmente, `genera-saluti` è una fabbrica di funzioni. In questo esempio usiamo `genera-saluti` per creare due nuove funzioni, una dice `Buon giorno` mentre l'altra dice `Buon Natale`.

`$giorno` e `$natale` sono entrambe delle chiusure. Esse condividono la stessa definizione di corpo, ma si portando dentro ambienti diversi. In `$giorno l'ambiente è `$periodo = "giorno"`. In `$natale` l'ambiente è `$periodo = "Natale"`

== Classi e oggetti
Nel capitolo precedente abbiamo imparato come Perl 6 faciliti la programmazione funzionale. +
In questo vedremo la programmazione orientata agli oggetti in Perl 6.

=== Introduzione

La _programmazione orientata agli oggetti_ è uno dei paradigmi maggiormente usati oggi. +
Un *oggetto* è un insieme di variabili e funzioni riuniti tutti insieme in una unità. +
Le variabili vengono chiamate *attributi* mentre le funzioni vengono chiamate *metodi*. +
Gli attributi definiscono lo *stato* mentre i metodi definiscono il *comportamento* di un oggetto.

Una *classe* è un modello per creare *oggetti*. +

Per capire le relazioni tra questi concetti considera questo esempio:

|===

| Ci sono quattro persone in una stanza | *oggetti* => 4 (persone)

| Queste persone sono esseri umani | *classe* => umano

| Essi hanno nomi, età, sesso e nazionalità diversi | *attributi* => nome, anni, sesso, nazione

|===

Nel gergo _orientato agli oggetti_ diciamo che gli oggetti sono *istanze* di una classe.

Considera questo script:
[source,perl6]
----
class umano {
  has $.nome;
  has $.anni;
  has $.sesso;
  has $.nazione;
}

my $giovanni = umano.new(nome => 'Giovanni', anni => 23, sesso => 'M', nazione => 'Italia');
say $giovanni;
----
La parole chiave `class` definisce la classe. +
`has` definisce gli attributi di una classe. +
Il metodo `.new()` è detto *costruttore*. Esso crea l'oggetto come una istanza della classe su cui è stato chiamato.

Nello script riportato qui sopra la nuova variabile `$giovanni` contiene un puntatore ad una nuova istanza di "umano" che è stata definita con `umano.new()`. +
Gli argomenti passati al metodo `.new()` vengono usati per definire gli attribuiti dell'oggetto sotteso.

L'_ambito lessicale_ di una classe può essere dato tramite `my`:
[source,perl6]
----
my class umano {

}
----

=== Incapsulazione
L'incapsulazione è un concetto del paradigma agli oggetti; esso racchiude dati e metodi di un oggetto in una unità. I dati (attributi) che si trovano all'interno dell'oggetto dovranno essere *privati*, ossia accessibili solamente dall'interno dell'oggetto. +
Per accedere agli attributi dall'esterno dell'oggetto bisognerà quindi usare speciali metodi detti *accessori* (ossia _che accedono_ n.d.t).

I due script qui sotto danno lo stesso risultato.

.Accesso diretto alla variabile:
[source,perl6]
----
my $var = 7;
say $var;
----

.Incapsulazione:
[source,perl6]
----
my $var = 7;
sub sayvar {
  $var;
}
say sayvar;
----
Il metodo `sayvar` è un metodo accessorio. Ci permette di accedere al valore di una variabile senza entrare in contatto diretto con essa.

L'incapsulazione è facilitata in Perl 6 grazie all'uso dei *sigilli secondari*. +
Si pongono tra il sigillo ed il nome dell'attributo. +
Ci sono due tipi di sigilli secondari per le classi:

* `!` viene usato per dichiarare esplicitamente che l'attributo è privato.
* `.` viene usato per generare automaticamente un accessore per l'attributo.

Tutti gli attributi sono privati, in mancanza di una precisazione diversa, ma è buona pratica usare sempre il sigillo secondario `!`.

Quindi, dovremmo riscrivere la classe in questa forma:
[source,perl6]
----
class umano {
  has $!nome;
  has $!anni;
  has $!sesso;
  has $!nazione;
}

my $giovanni = umano.new(nome => 'Giovanni', anni => 23, sesso => 'M', nazione => 'Italia');
say $giovanni;
----
Aggiungi allo script questa istruzione: `say $giovanni.anni;` +
Essa ti risponderà con un messaggio di errore: `Method 'anni' not found for invocant of class 'umano'`
perché `$!anni` è privata e può essere usata solo all'interno dell'oggetto.
Provando ad accedere ad essa dall'esterno l'oggetto ritorna un errore.

Sostituisci ora `has $!anni` con `has $.anni` ed osserva il risultato di `say $giovanni.anni;`

=== Parametri per nome e parametri per posizione
In Perl 6, tutte le classi ereditano un costruttore base `.new()`. +
Esso può essere usato per creare oggetti passandogli degli argomenti. +
Il costruttore base accetta solamente *argomenti nominali*. +
Nel nostro esempio qui sopra, nota che gli argomenti passati al costruttore sono definiti tramite un nome di riferimento:

* nome => 'Giovanni'

* anni => 23

Che accade se io non voglio fornire il nome di ciascun attributo ogni volta che voglio creare un oggetto?
Ho bisogno di creare un diverso costrutto, il quale accetti *argomenti posizionali*.

[source,perl6]
----
class umano {
  has $.nome;
  has $.anni;
  has $.sesso;
  has $.nazione;
  # nuovo costruttore che rimpiazza (override) quello base.
  method new ($nome,$anni,$sesso,$nazione) {
    self.bless(:$nome,:$anni,:$sesso,:$nazione);
  }
}

my $giovanni = umano.new('Giovanni',23,'M','Italia');
say $giovanni;
----

=== Metodi

==== Introduzione
I metodi sono le _subroutine_ di un oggetto. +
Come le subroutine, sono un mezzo di confezionare un insieme di funzionalità, accettano *argomenti*, hanno una *firma* e possono esser definiti *multi* ossia consentono l'overload.

I metodi sono definiti usando la parola chiave `method`. +
In circostanze normali, i metodi sono invocati per compiere certe azioini sugli attributi degli oggetti.
Questo implica il concetto di incapsulazione. Gli attributi di un oggetto possono essere manipolati dall'esterno dell'oggetto solo usando i metodi. 
Il mondo esterno può interagire con i metodi dell'oggetto e non ha accesso diretto ai suoi attributi.

[source,perl6]
----
class umano {
  has $.nome;
  has $.anni;
  has $.sesso;
  has $.nazione;
  has $.valido;
  method valuta-accesso {
      if self.anni < 21 {
        $!valido = 'No'
      } else {
        $!valido = 'Yes'
      }
  }

}

my $giovanni = umano.new(nome => 'Giovanni', anni => 23, sesso => 'M', nazione => 'Italia');
$giovanni.valuta-accesso;
say $giovanni.valido;
----

Una volta definiti all'interno della classe, i metodi possono essere invocati su un oggetto usando la _notazione punto_: +
_oggetto_ *.* _metodo_ oppure come nell'esempio sopra: `$giovanni.valuta-accesso`

Nella definizione di un metodo, se abbiamo bisogno di un riferimento all'oggetto stesso per chiamare un altro metodo dell'oggetto usiamo la parola chiave `self`. +

Nella definizione di un metodo, se abbiamo bisogno di un riferimento ad un attributo usiamo `!` anche se è stato definito con `.` +
Il concetto di base è questo: il sigillo secondario `.` dichiara un attributo con `!` ed automatizza la creazione di un accessore.

Nell'esempio sopra, `if self.anni < 21` ed `if $!anni < 21` avrebbero lo stesso effetto, sebbene essi siano tecnicamente diversi:

* `self.anni` invoca il metodo accessorio `.anni` +
Esso può anche essere scritto così `$.anni`
* `$!anni` è una accesso diretto alla variabile.

==== Metodi privati
I metodi ordinari possono essere invocati sugli oggetti dall'esterno della classe.

I *metodi privati* sono metodi che possono essere invocati solo dall'interno della classe. +
Un possibile uso di questi sono metodi che ne chiamano un'altro per un'azione specifica.
Il metodo che si interfaccia con l'esterno è pubblico, mentre l'altro privato.
Non vogliamo che l'utente lo invochi direttamente, quindi lo dichiariamo come privato.

La dichiarazione di un metodo privato richiede l'uso del sigillo secondario `!` prima del nome. +
I metodi privati sono chiamati con `!` invece di `.`

[source,perl6]
----
method !sonoprivato {
  # scrivi qui il tuo codice
}

method sonopubblico {
  self!sonoprivato;
  # qui fai altre cose
}
----

=== Attributi di classe

Gli *attributi di classe* sono attributi che appartengono alla classe stessa e non ai suoi oggetti. +
Essi possono essere inizializzati durante la definizione. +
Gli attributi di classe vengono dichiarati usanto `my` al posto di `has`. +
Sono invocati sulla classe stessa, invece che sugli oggetti.

[source,perl6]
----
class umano {
  has $.nome;
  my $.contatore = 0;
  method new($nome) {
    umano.contatore++;
    self.bless(:$nome);
  }
}
my $a = umano.new('a');
my $b = umano.new('b');

say umano.contatore;
----

=== Tipi di accesso agli attributi
Fino ad ora tutti gli esempi che abbiamo visto hanno usato accessori per *prendere* informazioni dagli oggetti.

Che accade se abbiamo bisogno di modificare il valore di un attributo? +
Abbiamo bisogno di marcarlo come _sia leggibile e scrivibile_ usando la parola chiave `is rw`.
[source,perl6]
----
class umano {
  has $.nome;
  has $.anni is rw;
}
my $giovanni = umano.new(nome => 'Giovanni', anni => 21);
say $giovanni.anni;

$giovanni.anni = 23;
say $giovanni.anni;
----
In mancanza di specificazioni, gli attributi vengono dichiarati come _solo leggibili non scrivibili_, ma questo tipo di accesso si può anche specificare esplicitamente tramite la parola chiave `is readonly`.

=== Inheritance
==== Introduction
*Inheritance* is another concept of object oriented programming.

When defining classes, soon enough we will realize that some attributes/methods are common to many classes. +
Should we duplicate code? +
NO! We should use *inheritance*

Let's consider we want to define two classes, a class for Human beings and a class for Employees. +
Human beings have 2 attributes: name and age. +
Employees have 4 attributes: name, age, company and salary

One would be tempted to define the classes as:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee {
  has $.name;
  has $.age;
  has $.company;
  has $.salary;
}
----
While technically correct, the above piece of code is considered conceptually poor.

A better way to write this would be:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee is Human {
  has $.company;
  has $.salary;
}
----
The `is` keyword defines inheritance. +
In object oriented parlance, we say Employee is a *child* of Human and that Human is a *parent* of Employee.

All child classes inherit the attributes and methods of the parent class, so there is no need to redefine them.

==== Overriding
Classes inherit all attributes and methods from their parent classes. +
There are cases where we need the method in the child class to behave differently than the one inherited. +
To achieve this, we redefine the method in the child class. +
This concept is called *overriding*.

In the below example, the method `introduce-yourself` is inherited by the Employee class.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi I am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
}

my $john = Human.new(name =>'John', age => 23,);
my $jane = Employee.new(name =>'Jane', age => 25, company => 'Acme', salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----
Overriding works like this:

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi I am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
  method introduce-yourself {
    say 'Hi I am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }

}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----

Depending of which class the object is, the right method will be called.

==== Submethods
*Submethods* are a type of method that are not inherited by child classes. +
They are only accessible from the class they were declared in. +
They are defined using the `submethod` keyword.

=== Multiple Inheritance
Multiple inheritance is allowed in Perl 6. A class can inherit from multiple other classes.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
----

.Explanation
The `combo-chart` class should be able to hold two series, one for the actual values plotted on bars,
and another for forecast values plotted on a line. +
This is why we defined it as a child of `line-chart` and `bar-chart`. +
You should have noticed that calling the method `plot` on the `combo-chart` didn't yield the required result.
Only one series was plotted. +
Why did this happen? +
`combo-chart` inherits from `line-chart` and `bar-chart`, and both of them have a method called `plot`.
When we call that method on `combo-chart` Perl 6 internals will try to resolve the conflict by calling one of the inherited methods.

.Correction
In order to behave correctly, we should have overridden the method `plot` in the `combo-chart`.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
[9 8 10 7 6 9]
----

=== Roles
*Roles* are similar to classes in that they are a collection of attributes and methods.

Roles are declared with the keyword `role`. Classes that wish to implement a role, do so using the `does` keyword.

.Let's rewrite the multiple inheritance example using roles:
[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

Run the above script and you will see that results are the same.

By now you're asking yourself: If roles behave like classes, what's their use? +
To answer your question, modify the first script used to showcase multiple inheritance,
the one where we _forgot_ to override the `plot` method.

[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
===SORRY!===
Method 'plot' must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)
----

.Explanation
If multiple roles are applied to the same class and a conflict exists, a compile-time error will be thrown. +
This is a much safer approach than multiple inheritance, where conflicts are not considered errors and are simply resolved at runtime.

Roles will warn you that there's a conflict.

=== Introspection
*Introspection* is the process of getting information about an object, like its type, attributes or methods.

[source,perl6]
----
class Human {
  has Str $.name;
  has Int $.age;
  method introduce-yourself {
    say 'Hi I am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has Str $.company;
  has Int $.salary;
  method introduce-yourself {
    say 'Hi I am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }
}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

say $john.WHAT;
say $jane.WHAT;
say $john.^attributes;
say $jane.^attributes;
say $john.^methods;
say $jane.^methods;
say $jane.^parents;
if $jane ~~ Human {say 'Jane is a Human'};
----
Introspection is facilitated by:

* `.WHAT` -- returns the class from which the object was created

* `.^attributes` -- returns all the attributes of the object

* `.^methods` -- returns all the methods that can be called on the object

* `.^parents` -- returns the parent classes of the object

* `~~` is called the smart-match operator.
It evaluates to _True_ if the object is created from the class it is being compared against or any of its inheritances.

[NOTA]
--
For more info on Object Oriented Programming in Perl 6, see:

* https://docs.perl6.org/language/classtut
* https://docs.perl6.org/language/objects
--
== Exception Handling

=== Catching Exceptions
*Exceptions* are a special behavior that happens at runtime when something goes wrong. +
We say that exceptions are _thrown_.

Consider the below script that runs correctly:

[source,perl6]
----
my Str $name;
$name = "Joanna";
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Hello Joanna
How are you doing today?
----

Now consider this script that throws an exception:

[source,perl6]
----
my Str $name;
$name = 123;
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Type check failed in assignment to $name; expected Str but got Int
   in block <unit> at exceptions.pl6:2
----

Notice that whenever an error occurs (in this case, assigning a number to a string variable) the program will stop and other lines of code will not be evaluated.

*Exception handling* is the process of _catching_ an exception that has been _thrown_ in order for the script to continue working.

[source,perl6]
----
my Str $name;
try {
  $name = 123;
  say "Hello " ~ $name;
  CATCH {
    default {
      say "Can you tell us your name again, we couldn't find it in the register.";
    }
  }
}
say "How are you doing today?";
----

.`Output`
----
Can you tell us your name again, we couldn't find it in the register.
How are you doing today?
----

Exception handling is done by using a `try-catch` block.

[source,perl6]
----
try {
  # code goes in here
  # if anything goes wrong, the script will enter the below CATCH block
  # if nothing goes wrong, the CATCH block will be ignored
  CATCH {
    default {
      # the code in here will be evaluated only if an exception has been thrown
    }
  }
}
----

The `CATCH` block can be defined the same way a `given` block is defined.
This means we can _catch_ and handle differently many types of exceptions.

[source,perl6]
----
try {
  # code goes in here
  # if anything goes wrong, the script will enter the below CATCH block
  # if nothing goes wrong, the CATCH block will be ignored
  CATCH {
    when X::AdHoc   { # do something if exception of type X::AdHoc is thrown }
    when X::IO      { # do something if exception of type X::IO is thrown }
    when X::OS      { # do something if exception of type X::OS is thrown }
    default         { # do something if exception is thrown and doesn't belong to the above types }
  }
}
----

=== Throwing Exceptions
Perl 6 also allows you to explicitly throw exceptions. +
Two types of exceptions can be thrown:

* ad-hoc exceptions

* typed exceptions

[source,perl6]
.ad-hoc
----
my Int $age = 21;
die "Error !";
----

[source,perl6]
.typed
----
my Int $age = 21;
X::AdHoc.new(payload => 'Error !').throw;
----

Ad-hoc exceptions are thrown using the `die` subroutine, followed by the exception message.

Typed exceptions are objects, hence the use of the `.new()` constructor in the above example. +
All typed exceptions descend from class `X` , below are a few examples: +
`X::AdHoc` is the simplest exception type +
`X::IO` is related to IO errors +
`X::OS` is related to OS errors +
`X::Str::Numeric` related to trying to coerce a string to a number

NOTA: For a complete list of exception types and their associated methods, go to https://docs.perl6.org/type-exceptions.html


== Regular Expressions
A regular expression, or _regex_, is a sequence of characters that is used for pattern matching. +
Think of it as a pattern.

[source,perl6]
----
if 'enlightenment' ~~ m/ light / {
    say "enlightenment contains the word light";
}
----

In this example, the smart match operator `~~` is used to check if a string (enlightenment) contains the word (light). +
"Enlightenment" is matched against the regex `m/ light /`

=== Regex definition

A regular expression can be defined like this:

* `/light/`

* `m/light/`

* `rx/light/`

Unless specified explicitly, white space is ignored; `m/light/` and `m/ light /` are the same.

=== Matching characters
Alphanumeric characters and the underscore `_` are written as is. +
All other characters have to be escaped using a backslash or surrounded by quotes.

[source,perl6]
.Backslash
----
if 'Temperature: 13' ~~ m/ \: / {
    say "The string provided contains a colon :";
}
----

[source,perl6]
.Single quotes
----
if 'Age = 13' ~~ m/ '=' / {
    say "The string provided contains an equal character = ";
}
----

[source,perl6]
.Double quotes
----
if 'name@company.com' ~~ m/ "@" / {
    say "This is a valid email address because it contains an @ character";
}
----

=== Matching categories of characters
Characters can be classified into categories and we can match against them. +
We can also match against the inverse of that category (everything except it):

|===

| *Category* | *Regex* | *Inverse* | *Regex*

| Word character (letter, digit or underscore) | \w | Any character except a word character | \W

| Digit | \d | Any character except a digit | \D

| Whitespace | \s | Any character except a whitespace | \S

| Horizontal whitespace | \h | Any character except a horizontal whitespace | \H

| Vertical whitespace | \v | Any character except a vertical whitespace | \V

| Tab | \t | Any character except a Tab | \T

| New line | \n | Any character except a new line | \N

|===

[source,perl6]
----
if "John123" ~~ / \d / {
  say "This is not a valid name, numbers are not allowed";
} else {
  say "This is a valid name"
}
if "John-Doe" ~~ / \s / {
  say "This string contains whitespace";
} else {
  say "This string doesn't contain whitespace"
}
----

=== Unicode properties
Matching against categories of characters, as seen in the preceding section, is convenient. +
That being said, a more systematic approach would be to use Unicode properties. +
This allows you to match against categories of characters inside and outside of +
the ASCII standard. +
Unicode properties are enclosed in `<: >`

[source,perl6]
----
if "Devanagari Numbers १२३" ~~ / <:N> / {
  say "Contains a number";
} else {
  say "Doesn't contain a number"
}
if "Привет, Иван." ~~ / <:Lu> / {
  say "Contains an uppercase letter";
} else {
  say "Doesn't contain an upper case letter"
}
if "John-Doe" ~~ / <:Pd> / {
  say "Contains a dash";
} else {
  say "Doesn't contain a dash"
}
----

=== Wildcards
Wildcards can also be used in a regex.

The dot `.` means any single character.

[source,perl6]
----
if 'abc' ~~ m/ a.c / {
    say "Match";
}
if 'a2c' ~~ m/ a.c / {
    say "Match";
}
if 'ac' ~~ m/ a.c / {
    say "Match";
} else {
    say "No Match";
}
----

=== Quantifiers
Quantifiers come after a character and are used to specify how many times we are expecting it.

The question mark `?` means zero or one time.

[source,perl6]
----
if 'ac' ~~ m/ a?c / {
    say "Match";
} else {
    say "No Match";
}
if 'c' ~~ m/ a?c / {
    say "Match";
} else {
    say "No Match";
}
----

The star `*` means zero or multiple times.

[source,perl6]
----
if 'az' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaz' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
if 'z' ~~ m/ a*z / {
    say "Match";
} else {
    say "No Match";
}
----

The `+` means at least one time.

[source,perl6]
----
if 'az' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaz' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
if 'z' ~~ m/ a+z / {
    say "Match";
} else {
    say "No Match";
}
----

=== Match Results
Whenever the process of matching a string against a regex is successful,
the match result is stored in a special variable `$/`

[source,perl6]
.Script
----
if 'Rakudo is a Perl 6 compiler' ~~ m/:s Perl 6/ {
    say "The match is: " ~ $/;
    say "The string before the match is: " ~ $/.prematch;
    say "The string after the match is: " ~ $/.postmatch;
    say "The matching string starts at position: " ~ $/.from;
    say "The matching string ends at position: " ~ $/.to;
}
----

.Output
----
The match is: Perl 6
The string before the match is: Rakudo is a
The string after the match is: compiler
The matching string starts at position: 12
The matching string ends at position: 18
----

.Explanation
`$/` returns a _Match Object_ (the string that matches the regex) +
The following methods can be called on the _Match Object_: +
`.prematch` returns the string preceding the match. +
`.postmatch` returns the string following the match. +
`.from` returns the starting position of the match. +
`.to` returns the ending position of the match. +

Noticina: By default, whitespace in a regex definition is ignored. +
If we want to match against a regex containing whitespace, we have to do so explicitly. +
The `:s` in the regex `m/:s Perl 6/` forces whitespace to be considered. +
Alternatively, we could have written the regex as `m/ Perl\s6 /` and used `\s` which represents a whitespace. +
If a regex contains more than a single whitespace, using `:s` is a better option than using `\s` for each and every whitespace.

=== Example
Let's check if an email is valid or not. +
For the sake of this example we will assume that a valid email address has this format: +
first name [dot] last name [at] company [dot] (com/org/net)

WARNING: The regex used in this example for email validation is not very accurate. +
Its sole purpose is to demonstrate regex functionality in Perl 6. +
Do not use it as-is in production.

[source,perl6]
.Script
----
my $email = 'john.doe@perl6.org';
my $regex = / <:L>+\.<:L>+\@<:L+:N>+\.<:L>+ /;

if $email ~~ $regex {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

.Output
`john.doe@perl6.org is a valid email`

.Explanation
`<:L>` matches a single letter +
`<:L>+` matches one or more letters +
`\.` matches a single [dot] character +
`\@` matches a single [at] character +
`<:L+:N>` matches a letter or a single number +
`<:L+:N>+` matches one or more letters or numbers +

The regex can be decomposed as following:

* *first name* `<:L>+`

* *[dot]* `\.`

* *last name* `<:L>+`

* *[at]* `\@`

* *company name* `<:L+:N>+`

* *[dot]* `\.`

* *com/org/net* `<:L>+`

[source,perl6]
.Alternatively, a regex can be broken down into multiple named regexes
----
my $email = 'john.doe@perl6.org';
my regex many-letters { <:L>+ };
my regex dot { \. };
my regex at { \@ };
my regex many-letters-numbers { <:L+:N>+ };

if $email ~~ / <many-letters> <dot> <many-letters> <at> <many-letters-numbers> <dot> <many-letters> / {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

A named regex is defined using the following syntax: `my regex regex-name { regex definition }` +
A named regex can be called using the following syntax: `<regex-name>`

NOTA: For more info on regexes, see https://docs.perl6.org/language/regexes

== Perl 6 Modules
Perl 6 is a general purpose programming language. It can be used to tackle a multitude of tasks including:
text manipulation, graphics, web, databases, network protocols etc.

Reusability is a very important concept whereby programmers don't have to reinvent the wheel each time they want to do a new task.

Perl 6 allows the creation and redistribution of *modules*. Each module is a packaged set of functionality that can be reused once installed.

_Zef_ is a module management tool that comes with Rakudo Star.

To install a specific module, type the below command in your terminal:

`zef install "module name"`

NOTA: The Perl 6 modules directory can be found on: https://modules.perl6.org/

=== Using Modules
MD5 is a cryptographic hash function that produces a 128-bit hash value. +
MD5 has a variety of applications, including the encryption of stored passwords in a database.
When a new user registers, their credentials are not stored as plain text but rather _hashed_.
The rationale behind this is that if the DB gets compromised, the attacker will not be able to know what the passwords are.

Luckily, you don't need to implement the MD5 algorithm yourself; there's a Perl 6 module already implemented.

Let's install it: +
`zef install Digest::MD5`

Now, run the below script:
[source,perl6]
----
use Digest::MD5;
my $password = "password123";
my $hashed-password = Digest::MD5.new.md5_hex($password);

say $hashed-password;
----
In order to run the `md5_hex()` function that creates hashes, we need to load the required module. +
The `use` keyword loads the module for use in the script.

WARNING: In practice MD5 hashing alone is not sufficient, because it is prone to dictionary attacks. +
It should be combined with a salt link:https://en.wikipedia.org/wiki/Salt_(cryptography)[https://en.wikipedia.org/wiki/Salt_(cryptography)].

== Unicode

Unicode is a standard for encoding and representing text for most writing systems in the world. +
UTF-8 is a character encoding capable of encoding all possible characters, or code points, in Unicode.

Characters are defined by a: +
*Grapheme*: Visual representation. +
*Code point*: A number assigned to the character.

=== Using Unicode

.Let's look at how we can output characters using Unicode
[source,perl6]
----
say "a";
say "\x0061";
say "\c[LATIN SMALL LETTER A]";
----
The above 3 lines showcase different ways of building a character:

. Writing the character directly (grapheme)

. Using `\x` and the code point

. Using `\c` and the code point name

.Now lets output a smiley
[source,perl6]
----
say "☺";
say "\x263a";
say "\c[WHITE SMILING FACE]";
----

.Another example combining two code points
[source,perl6]
----
say "á";
say "\x00e1";
say "\x0061\x0301";
say "\c[LATIN SMALL LETTER A WITH ACUTE]";
----

The letter `á` can be written:

* using its unique code point `\x00e1`

* or as a combination of the code points of `a` and acute `\x0061\x0301`

.Some of the methods that can be used:
[source,perl6]
----
say "á".NFC;
say "á".NFD;
say "á".uniname;
----

.`Output`
----
NFC:0x<00e1>
NFD:0x<0061 0301>
LATIN SMALL LETTER A WITH ACUTE
----

`NFC` returns the unique code point. +
`NFD` decomposes the character and return the code point of each part. +
`uniname` returns the code point name.

.Unicode letters can be used as identifiers:
[source,perl6]
----
my $Δ = 1;
$Δ++;
say $Δ;
----

.Unicode can be used to do math:
[source,perl6]
----
my $var = 2 + ⅒;
say $var;
----

== Parallelism, Concurrency and Asynchrony

=== Parallelism
Under normal circumstances, all tasks in a program run sequentially. +
This might not be a problem, unless what you're trying to do takes a lot of time.

Thankfully, Perl 6 has features that will enable you to run things in parallel. +
At this stage, it is important to note that parallelism can mean one of two things:

* *Task Parallelism*: Two (or more) independent expressions running in parallel.

* *Data Parallelism*: A single expression iterating over a list of elements in parallel.

Let's begin with the latter.

==== Data Parallelism
[source,perl6]
----
my @array = (0..50000);                     # Array population
my @result = @array.map({ is-prime $_ });   # call is-prime for each array element
say now - INIT now;                         # Output the time it took for the script to complete
----

.Considering the above example:
We are only doing one operation `@array.map({ is-prime $_ })` +
The `is-prime` subroutine is being called for each array element sequentially: +
`is-prime @array[0]` then `is-prime @array[1]` then `is-prime @array[2]` etc.

.Fortunately we can call `is-prime` on multiple array elements at the same time:
[source,perl6]
----
my @array = (0..50000);                         # Array population
my @result = @array.race.map({ is-prime $_ });  # call is-prime for each array element
say now - INIT now;                             # Output the time it took to complete
----

Notice the use of `race` in the expression.
This method will enable parallel iteration of the array elements.

After running both examples (with and without `race`), compare the time it took for both scripts to complete.

[Noticina]
====
`race` will not preserve the order of elements. If you wish to do, so use `hyper` instead.

[source,perl6]
.race
----
my @array = (1..1000);
my @result = @array.race.map( {$_ + 1} );
.say for @result;
----

[source,perl6]
.hyper
----
my @array = (1..1000);
my @result = @array.hyper.map( {$_ + 1} );
.say for @result;
----

If you run both examples, you should notice that one is sorted and the other is not.

====

==== Task Parallelism

[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my @result1 = @array1.map( {is-prime($_ + 1)} );
my @result2 = @array2.map( {is-prime($_ - 1)} );

say @result1 eqv @result2;

say now - INIT now;
----

.Considering the above example:

. We defined 2 arrays

. applied a different operation for each array and stored the results

. and checked if both results are the same

The script waits for `@array1.map( {is-prime($_ + 1)} )` to finish +
and then evaluates `@array2.map( {is-prime($_ - 1)} )`

Both operations applied to each array do not depend on each other.

.Why not do both in parallel?
[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my $promise1 = start @array1.map( {is-prime($_ + 1)} ).eager;
my $promise2 = start @array2.map( {is-prime($_ - 1)} ).eager;

my @result1 = await $promise1;
my @result2 = await $promise2;

say @result1 eqv @result2;

say now - INIT now;
----

.Explanation
The `start` subroutine evaluates the code and returns *an object of type promise* or shortly *a promise*. +
If the code is evaluated correctly, the _promise_ will be *kept*. +
If the code throws an exception, the _promise_ will be *broken*.

The `await` subroutine waits for a *promise*. +
If it's *kept* it will get the returned values. +
If it's *broken* it will get the exception thrown.

Check the time it took each script to complete.

WARNING: Parallelism always adds a threading overhead. If that overhead is not offset by gains in computational speed, the script will seem slower. +
This is why, using `race`, `hyper`, `start` and `await` for fairly simple scripts can actually slow them down.

=== Concurrency and Asynchrony
NOTA: For more info on Concurrency and Asynchronous Programming, see https://docs.perl6.org/language/concurrency

== Native Calling Interface

Perl 6 gives us the ability to use C libraries, using the Native Calling Interface.

`NativeCall` is a standard module that ships with Perl 6 and offers a set of functionality to ease the job
of interfacing Perl 6 and C.

=== Calling a function

Consider the below C code that defines a function called `hellofromc`.
This function prints on the terminal `Hello from C`. It doesn't accept any argument nor return any value.

[source,c]
.ncitest.c
----
#include <stdio.h>

void hellofromc () {
  printf("Hello from C\n");
}
----

Depending on your OS run the following commands to compile the above C code into a library.

.On Linux:
----
gcc -c -fpic ncitest.c
gcc -shared -o libncitest.so ncitest.o
----

.On Windows:
----
gcc -c ncitest.c
gcc -shared -o ncitest.dll ncitest.o
----

Within the same directory where you compiled your C library, create a new Perl 6
file that contains the below code and run it.

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub hellofromc() is native(LIBPATH) { * }

hellofromc();
----

.Explanation:
First of all we declared that we will be using the `NativeCall` module. +
Then we created a constant `LIBPATH` that holds the path to the C library. +
Notice that `$*CWD` returns the current working directory. +
Then we created a new Perl 6 subroutine called `hellofromc()` that should act as a
wrapper to its counterpart C function having the same name and residing in the C
library found in `LIBPATH`. +
All of this was done by using the `is native` trait. +
Finally we called our Perl 6 subroutine.

In essence, it all boils down to declaring a subroutine with the trait `is native` and the name of the C library.

=== Renaming a function

In the above part, we saw how we can call a very simple C function by wrapping
it with a Perl 6 subroutine having the same name, using the `is native` trait.

In some cases, we would want to change the name of the Perl 6 subroutine. +
To do so, we use the `is symbol` trait.

Lets modify the above Perl 6 script and rename the Perl 6 subroutine `hello`
instead of `hellofromc`

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub hello() is native(LIBPATH) is symbol('hellofromc') { * }

hello();
----

.Explanation:
In case the Perl 6 subroutine has a different name than its C counterpart, we
should use the `is symbol` trait with the name of the original C function.

=== Passing Arguments

Compile the following modified C library and run the Perl 6 script found below again. +
Notice how we modified both C and Perl 6 code to accept a string (`char*` in C and `Str` in Perl 6)

[source,c]
.ncitest.c
----
#include <stdio.h>

void hellofromc (char* name) {
  printf("Hello, %s! This is C!\n", name);
}
----

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub hello(Str) is native(LIBPATH) is symbol('hellofromc') { * }

hello('Jane');
----

=== Returning values

Lets repeat the process one more time and create a simple calculator that takes
2 integers and add them. +
Compile the C library and run the Perl 6 script.

[source,c]
.ncitest.c
----
int add (int a, int b) {
  return (a + b);
}
----

[source,perl6]
.ncitest.pl6
----
use NativeCall;

constant LIBPATH = "$*CWD/ncitest";
sub add(int32,int32) returns int32 is native(LIBPATH) { * }

say add(2,3);
----

Notice how both C and Perl 6 functions accept two integers and return one
(`int` in C and `int32` in Perl 6)

=== Types

You might have asked yourself why did we use `int32` instead of `Int` in the latest Perl 6 script. +
Some Perl 6 types like `Int`, `Rat` etc. can't be used as is to pass and receive values from a C function. +
One must use in Perl 6 the same types as the ones in C.

Luckily Perl 6 provides many types that map to their respective C counterpart.

[cols="^.^,^.^",options="header"]
|===

| C Type | Perl 6 Type

| `char` .2+| `int8`

| `int8_t`

| `short` .2+| `int16`

| `int16_t`

| `int` .2+| `int32`

| `int32_t`

| `int64_t` | `int64`

| `unsigned char` .2+| `uint8`

| `uint8_t`

| `unsigned short` .2+| `uint16`

| `uint16_t`

| `unsigned int` .2+| `uint32`

| `uint32_t`

| `uint64_t` | `uint64`

| `long` | `long`

| `long long` | `longlong`

| `float` | `num32`

| `double` | `num64`

| `size_t` | `size_t`

| `bool` | `bool`

| `char*` (String) | `Str`

| Arrays: For example `int*` (Array of int) and `double*` (Array of double) | `CArray`: For example `CArray[int32]` and `CArray[num64]`

|===

NOTA: For more info on the Native Calling Interface, see https://docs.perl6.org/language/nativecall

== The Community

* link:irc://irc.freenode.net/#perl6[#perl6] IRC channel. Much discussion happens on IRC. This should be your go to place for any enquiry: https://perl6.org/community/irc

* link:https://p6weekly.wordpress.com[p6weekly] a weekly overview of changes in and around Perl 6.

* link:http://pl6anet.org[pl6anet] blog aggregator. Stay tuned by reading blog posts that focus on Perl 6.

* link:https://www.reddit.com/r/perl6/[/r/perl6] Subscribe to the Perl 6 subreddit.
